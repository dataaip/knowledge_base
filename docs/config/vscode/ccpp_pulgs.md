## C/C++ Extension Pack 插件配置
VSCode 上使用 C/C++ Extension Pack 插件搭建 C/C++ 开发环境`Clang + C/C++ Extension Pack(C/C++、C/C++ Themes)`的方式。  

### 1、先决条件配置
- 安装 VSCode 官网: https://code.visualstudio.com/docs/setup/mac.     
- 安装 C/C++ 扩展插件: C/C++ Extension Pack 包含(C/C++、C/C++Themes、CMake Tools)等。  
- 在 MacOS 上安装 Clang 编译器，并检查编译器的版本。    
  ```bash 
  # 使用 macos 上的 xcode 开发工具包安装 clang 编译器
  xcode-select --install
  
  # 运行下列命令检查 clang 版本
  clang --version
  ```

### 2、编译调试设置
- C/C++ Extension Pack 插件 需要在`.vscode`文件夹下配置三个文件。   
  > `tasks.json`(编译器构建设置 compiler build settings)  
  > `launch.json`(调试器设置 debugger settings)  
  > `c_cpp_properties.json`(编译器路径和 IntelliSense 设置 compiler path and IntelliSense settings)    
  
- 在 MacOS 终端创建一个目录 codeMastery 文件夹。
  ```bash
  mkdir codeMastery
  cd codeMastery
  code .
  ```
- 在 VSCode 中创建一个`main.cpp`源文件，粘贴以下源代码，保存文件。
  ``` cpp
  #include <iostream>
  #include <vector>
  #include <string>
  
  using namespace std;
  
  int main()
  {
      vector<string> msg {"Hello", "C/C++", "World", "from", "VS Code", "and the C/C++ extension!"};
  
      for (const string& word : msg)
      {
          cout << word << " ";
      }
      cout << endl;
  }
  ```
- 运行`main.cpp`源文件时 C/C++ Extension 插件会使用系统的 C++ 编译器来构建程序。在`main.cpp`运行和调试之前需要确保安装了 C/C++ 编译器(Clang/GCC)。例如在使用 Clang 编译器运行源文件时 VSCode 将从系统上检测到的编译器列表中选择 C/C++: clang++ build and debug active file 来进行构建和调试。

### 3、编译器构建设置 tasks.json
- 运行`main.cpp`后会在 `.vscode` 文件中生成一个 `tasks.json`(编译器构建设置) 文件。
  ```json
  {
      "tasks": [
          {
              "type": "cppbuild",
              "label": "C/C++: clang build active file",
              "command": "/usr/bin/clang++",  
              "args": [                       
                  "-fcolor-diagnostics",
                  "-fansi-escape-codes",
                  "-g",                       
                  "${file}",                                 
                  "-o",                       
                  "${fileDirname}/${fileBasenameNoExtension}" 
              ],
              "options": {
                  "cwd": "${fileDirname}"
              },
              "problemMatcher": [
                  "$gcc"
              ],
              "group": {
                  "kind": "build",
                  "isDefault": true
              },
              "detail": "Task generated by Debugger."
          }
      ],
      "version": "2.0.0"
  }
  ```
  > `"tasks"`: 任务数组，每个任务都是一个编译或构建步骤。此示例中只有一个任务。   
  > `"type"`: 任务类型，这里是 "cppbuild"。  
  > `"label"`: 任务标签描述了任务的功能，这里的意思是 "C/C++: clang build active file"。   
  > `"command"`: 要执行的命令，这里是 "/usr/bin/clang++" 代表使用 Clang++ 编译器编译 C/C++ 代码。   
  > `"args"`: 命令行参数数组，被传递给 `command` 各个参数的含义如下  
  > `-fcolor-diagnostics`: 要求 Clang 使用颜色输出诊断信息。  
  > `-fansi-escape-codes`: 启用 ANSI escape code 解析。  
  > `-g`: 生成调试信息，使得可以使用如 GDB/LLDB 的调试工具进行调试。  
  > `"${file}"`: 当前打开的文件，这是 VSCode 的内置变量。  
  > `-o`: 输出文件的选项。  
  > `"${fileDirname}/${fileBasenameNoExtension}"`: 输出文件的路径和名称，这里将在源文件的同一目录下生成一个没有扩展名的输出文件。  
  > `"options"`: 选项，`"cwd": "${fileDirname}"` 指定当前工作目录为源文件的目录。  
  > `"problemMatcher"`: 问题匹配器，这里使用的是 gcc 用于解析编译器的输出并在 VSCode 中高亮显示问题。  
  > `"group"`: 组选项，`"kind": "build"` 指定这是一个构建任务`"isDefault": true` 指定这是默认的构建任务。  
  > `"detail"`: 任务详细描述，这里的描述是 "Task generated by Debugger."  
  > `"version"`: 任务配置的版本，这里是 "2.0.0"。

- 运行`main.cpp` 时将会读取 `tasks.json` 进行构建和运行程序。可以在 `tasks.json` 中定义多个构建任务，并且标记为默认的任务就是运行按钮使用的任务。如果需要更改默认编译器打开命令面板 (CTRL(CMD)+SHIFT+P) 搜索 Tasks: Configure Default Build Task 进行配置。
  ```json
  {
      "tasks": [
          {
              "type": "cppbuild",
              "label": "C/C++: clang++ build active file",
              "command": "/usr/bin/clang++",
              "args": [
                  "-fcolor-diagnostics",
                  "-fansi-escape-codes",
                  "-g",
                  "${file}",
                  "-o",
                  "${fileDirname}/${fileBasenameNoExtension}"
              ],
              "options": {
                  "cwd": "${fileDirname}"
              },
              "problemMatcher": [
                  "$gcc"
              ],
              "group": {
                  "kind": "build",
                  "isDefault": true
              },
              "detail": "Task generated by Debugger."
          },
          {
              "type": "cppbuild",
              "label": "C: clang build active file",
              "command": "/usr/bin/clang",
              "args": [
                  "-fcolor-diagnostics",
                  "-fansi-escape-codes",
                  "-g",
                  "${file}",
                  "-o",
                  "${fileDirname}/${fileBasenameNoExtension}"
              ],
              "options": {
                  "cwd": "${fileDirname}"
              },
              "problemMatcher": [
                  "$gcc"
              ],
              "group": {
                  "kind": "build",
                  "isDefault": true
              },
              "detail": "Task generated by Debugger."
          }
      ],
      "version": "2.0.0"
  }
  ```
- 当构建多个 C/C++ 文件时比如构建当前文件夹中的所有文件就要用 "${workspaceFolder}/*.cpp" 替换 "${file}" 来构建该工作空间文件夹下所有的 `.cpp` 文件，修改 "${fileDirname}/${fileBasenameNoExtension}" 硬编码文件名为"${workspaceFolder}/myProgram.out" 输出文件。
  ```json
  {
      "tasks": [
          {
              "type": "cppbuild",
              "label": "C/C++: clang build active file",
              "command": "/usr/bin/clang++",  
              "args": [
                  "-std=gnu++17",                       
                  "-fcolor-diagnostics",
                  "-fansi-escape-codes",
                  "-g",                       
                  "${workspaceFolder}/*.cpp",                                 
                  "-o",                       
                  "${workspaceFolder}/myProgram.out" 
              ],
              "options": {
                  "cwd": "${fileDirname}"
              },
              "problemMatcher": [
                  "$gcc"
              ],
              "group": {
                  "kind": "build",
                  "isDefault": true
              },
              "detail": "Task generated by Debugger."
          }
      ],
      "version": "2.0.0"
  }  
  ```
  ```bash
  # task.json 配置相当于生成如下的命令行编译命令编译运行文件
  /usr/bin/clang++ -std=gnu++14 -fcolor-diagnostics -fansi-escape-codes -g ${file} -o ${fileDirname}/${fileBasenameNoExtension}
  ```

### 4、调试 DeBug 设置 launch.json  
- 在源文件`main.cpp`中 设置代码断点`F9` 选择 DeBug C/C++ File，将从系统上检测到的编译器列表中选择 C/C++: clang++ build and debug active file 运行。运行有两种模式：Run C/C++ File 和 Debug C/C++ File，选择 DeBug C/C++ File 启动调试器进行单步执行代码、设置监视窗口追踪变量的值。  
- 使用`launch.json`可以进行自定义调试，使用`F5`进行调试时 C/C++ Extension 插件会动态创建动态调试配置，在某些情况下需要自定义调试配置例如指定在运行时传递给程序的参数。  
- 创建 `launch.json`打开命令面板 (CTRL(CMD)+SHIFT+P) 搜索 C/C++ : Add Debug Configuration 然后可以看到各种预定义调试配置的下拉列表，选择 C/C++: clang++ build and debug active file 进行配置。   
  ```json
  {
      "configurations": [
          {
              "name": "C/C++: clang++ build and debug active file",
              "type": "cppdbg",
              "request": "launch",
              "program": "${fileDirname}/${fileBasenameNoExtension}",
              "args": [],
              "stopAtEntry": false,
              "cwd": "${fileDirname}",
              "environment": [],
              "externalConsole": false,
              "MIMode": "lldb",
              "preLaunchTask": "C/C++: clang build active file"
          }
      ],
      "version": "2.0.0"
  }  
  ```
  > `name`: 配置的名称，在这里它是 "C/C++: clang++ build and debug active file"。   
  > `type`: 配置的类型，在这里它是 "cppdbg" 表示使用 C++ 的调试器。   
  > `request`: 请求类型，在这里它是 "launch" 意味着会启动一个新的程序。   
  > `program`: 需要启动或附加的程序的路径，在这里它是 "${fileDirname}/${fileBasenameNoExtension}" 表示在当前工作空间的 ${fileDirname} 目录下的 ${fileBasenameNoExtension} 文件。   
  > `args`: 传递给程序的命令行参数，在这里没有提供参数。   
  > `stopAtEntry`: 如果为真程序会在主函数处停止，在这里它是 false 所以在主函数处不会停止。   
  > `cwd`: 程序的当前工作目录，在这里它是 "${fileDirname}"  表示程序的当前工作目录与所选文件的目录相同。   
  > `environment`: 为程序设置的环境变量。在这里没有设置环境变量。   
  > `externalConsole`: 如果为真会使用外部控制台，在这里它是 false 所以不会使用外部控制台。   
  > `MIMode`: 指定要使用的调试器，在这里它是 "lldb" 表示使用的是 LLDB 调试器。   
  > `preLaunchTask`: 启动前要运行的任务名称，在这里它是 "C/C++: clang build active file" 表示在启动程序之前会先运行名为 "C/C++: clang build active file" 的任务。  
  > `version`: 配置文件版本，这里是"2.0.0"。  
- 从现在开始，在启动程序进行调试时，播放按钮和`F5`将会从`launch.json` 文件中读取。 

### 5、附加 C/C++ 设置 c_cpp_properties.json
- 为了更好地控制 C/C++ Extension 还需要创建一个 `c_cpp_properties.json` 文件，该文件允许您更改编译器路径、包含路径、要针对哪个 C++ 标准进行编译（例如 c++17）等设置。  
- 通过 (CTRL(CMD)+SHIFT+P) 选择 C/C++: Edit Configurations (UI) 查看 C/C++ 配置会生成一个 `c_cpp_properties.json` 文件 VSCode 将这些设置放置在 `.vscode/c_cpp_properties.json`中。 
  ```json
  {
      "configurations": [
          {
              "name": "Mac",
              "includePath": [
                  "${workspaceFolder}/**"
              ],
              "defines": [],
              "macFrameworkPath": [
                  "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks"
              ],
              "compilerPath": "/usr/bin/clang",
              "cStandard": "c17",
              "cppStandard": "c++17",
              "intelliSenseMode": "macos-clang-arm64"
          }
      ],
      "version": 4
  }  
  ```
  > `configurations`: 这个数组包含了一个配置对象，定义了一组特定于平台的设置。  
  > `name`: 配置的名称，这里是 "Mac"。  
  > `includePath`: 这个数组定义了编译器在查找包含文件时要遍历的路径 `${workspaceFolder}/**` 表示在当前工作区的所有目录中查找。  
  > `defines`: 这个数组定义了预处理器宏，这里没有定义任何宏。    
  > `macFrameworkPath`: 这个数组定义了 MacOS 框架的搜索路径，这里的路径是 MacOSX SDK 的系统库路径。   
  > `compilerPath`: 这个字段定义了编译器的路径，这里使用的是 Clang 编译器。  
  > `cStandard`: 这个字段定义了要使用的 C 语言标准，这里是 "c17"。  
  > `cppStandard`: 这个字段定义了要使用的 C++ 语言标准，这里是 "c++17"。  
  > `intelliSenseMode`: 这个字段定义了要使用的 IntelliSense 模式，这里是 "macos-clang-arm64" 表示使用的是  MacOS 平台的 Clang 编译器，并且目标架构是 ARM64。
  > `version`: 这个字段定义了配置文件的版本，这里是版本4。