/**
* @file              static.c
* @brief             存储期与链接，存储类说明符 指定对象和函数的存储期（storage duration）和链接（linkage）
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2024.12.24
* @copyright         Copyright (c) 2024.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2024.12.24 <td>0.1             <td>brightl         <td>static关键词使用，解释说明
* </table>
*/

#include "c/basics/variable/variable.h"
#include <stdio.h>

/**
* @brief             brief
*
* @note              存储类说明符为变量和函数的生命周期、可见性及访问权限提供了灵活的控制手段，有助于优化内存使用和程序性能
*/
#define STATIC_WORDS

/**
* @brief             static - 静态存储期与内部链接（除非在块作用域）
* @return  int       Return Description
*
* @note              Revision History
*/
int static_fn(void) {
#ifdef STATIC_WORDS
  /*
  static - 静态存储期与内部链接（除非在块作用域）

  static
  静态存储期：static 变量在程序的整个生命周期内存在，从程序启动到程序结束
  内部链接：在文件作用域中定义的 static 变量或函数只能在该文件中使用
  块作用域：在块作用域中定义的 static 变量具有静态存储期，但没有链接，仍然只能在定义它的代码块中使用
  static int globalVar = 100; // 文件作用域，只能在这个文件中访问
  void function() {
    static int z = 30;        // 块作用域，z 是一个静态存储期的局部变量，生命周期为整个程序期间
  }

  解释
  1、存储类说明符出现于声明和复合字面量表达式(C23起)中。至多可使用一个说明符，但可以将 _Thread_local(C23 前)thread_local(C23 起) 与 static 或 extern 组合以调整链接(C11 起)。存储类说明符确定其所声明的名称的两个独立属性：存储期与链接
  auto 说明符只允许用于声明于块作用域的对象（除了函数形参列表）。它指示自动存储期与无链接，也是这种声明的默认属性
  register 说明符只允许用于声明于块作用域的对象，包括函数形参列表。它指示自动存储期与无链接（即这种声明的默认属性），但另外提示优化器，若可能则将此对象的值存储于 CPU 寄存器中。无论此优化是否发生，声明为 register 的对象不能用作取址运算符的参数，不能用 alignas(C11 起)，而且 register 数组不能转换为指针
  static 说明符指定静态存储期（除非与 _Thread_local 组合）(C11起)和内部链接（除非用于块作用域）。它能用于在 文件作用域的函数，以及 文件 和 块作用域的变量，但不能用于函数形参列表
  extern 指定静态存储期（除非与 _Thread_local(C23 前)thread_local(C23 起) 组合）(C11 起)和外部链接。它能用于 文件 和 块作用域中 的 函数和对象 声明（除了函数形参列表）。若 extern 出现在已经声明带内部链接的标识符上，则链接仍为内部。否则（若前一声明为外部、无链接或不在作用域内）链接则为外部链接
  
  _Thread_local(C23 前)thread_local(C23 起) 指示线程存储期。它不能用于函数声明。若将它用在对象声明上，则它必须在同一对象的每次声明上都存在。若将它用在块作用域声明上，则必须与 static 或 extern 之一组合以决定链接，线程存储期：指定变量在所属线程的整个生命周期内存在。每个线程都有自己独立的变量副本，互不干扰。这些变量会在线程创建时被初始化，并在线程结束时销毁
  对象声明的一致性：如果 _Thread_local 或 thread_local 用在对象声明上，它必须在该对象的每次声明中都存在。这确保了所有的声明一致指示该对象具有线程存储期
  块作用域：当在块作用域（如函数内部）使用 _Thread_local 或 thread_local 说明符时，必须与 static 或 extern 之一组合使用。这是因为在块作用域中需要明确指定存储期和链接属性

  2、若不提供存储类说明符，则默认为，对所有函数为 extern、对在文件作用域的对象为 extern、对在块作用域的对象为 auto
  
  3、存储类说明符在结构体或联合体中的应用，当用存储类说明符（如 static, extern, _Thread_local, 或 thread_local）来声明结构体或联合体时，这些存储期规范会递归地应用到结构体或联合体的每个成员     

  4、在块作用域（如函数内部），函数声明可以使用 extern 也可以完全不使用存储类说明符，extern 函数声明表示函数可以在其他文件中访问（具有外部链接）
  5、在文件作用域（全局变量和函数的顶层作用域），函数声明可以使用 extern 或 static，static 函数声明表示函数只能在定义它的文件中访问（具有内部链接）

  6、函数形参不能使用除 register 以外的存储类说明符。register 提示编译器尽量将变量存储在寄存器中，以提高访问速度
  7、static 在数组类型的函数形参中的特殊含义 在数组类型的函数形参中，static 有特殊含义。它提示调用函数时，传递的数组指针所指向的数组至少有指定的元素数目，这对于优化可以很有帮助
  
  存储期
  4、每个对象都有一个名为 存储期 的属性，它限制了对象的生命周期。在 C 语言中有四种存储期
  在 C 语言中，每个对象都有一个称为存储期的属性，它决定了对象何时分配和释放内存。C 中有四种存储期：自动存储期、静态存储期、线程存储期和分配存储期
  - 自动存储期 (Automatic Storage Duration)
  - 分配和释放：当程序执行进入对象所声明于其中的块（例如函数或代码块）时，自动分配该对象的存储；当退出该块时，无论是通过 goto、return 还是正常到达块的结尾，存储都会被释放
  - VLA（变长数组）：从 C99 起，VLA 的存储是在执行声明时分配的，而不是在块入口时分配的，存储在声明离开作用域时解分配而非退出块时解分配
  - 递归：如果递归地进入同一个块，每次递归调用都会进行新的存储分配
  - 适用对象：所有函数形参和非 static 块作用域的对象，以及在块作用域中使用的复合字面量（C23前）都拥有自动存储期
  - 
  - 静态存储期 (Static Storage Duration)
  - 分配和释放：存储期是整个程序的执行过程，只在 main 函数之前初始化一次，存储直到程序结束
  - 适用对象：所有声明为 static 的对象和所有带内部或外部链接且未声明为 _Thread_local（C23前）或 thread_local（C23起）的对象都拥有静态存储期
  - 
  - 线程存储期 (Thread Storage Duration) (C11起)
  - 分配和释放：存储期是创建该对象的线程的整个执行过程，在线程启动时初始化存储，在线程结束时释放存储。每个线程都有自己独立的对象副本
  - 注意事项：如果一个线程访问另一个线程初始化的 thread_local 对象，行为是实现定义的
  - 适用对象：所有声明为 _Thread_local（C23前）或 thread_local（C23起）的对象拥有线程存储期
  - 
  - 分配存储期 (Allocated Storage Duration)
  - 分配和释放：通过动态内存分配函数（如 malloc、calloc、realloc）进行分配，并通过 free 函数进行释放。存储期由程序员显式控制
  - 适用对象：所有通过动态内存分配函数分配的对象都拥有分配存储期
  - 
  - 自动存储期：对象在进入块时分配，退出块时释放。典型对象包括函数形参和非 static 块作用域对象
  - 静态存储期：对象在程序开始时分配，程序结束时释放。典型对象包括声明为 static 和具有内部或外部链接的全局变量
  - 线程存储期：对象在线程开始时分配，线程结束时释放。典型对象包括声明为 _Thread_local 或 thread_local 的变量
  - 分配存储期：对象通过动态内存分配函数分配，并通过 free 释放。典型对象包括通过 malloc、calloc 或 realloc 分配的内存

  链接
  5、在 C 语言中，链接（linkage）指的是变量或函数标识符在不同作用域之间的可见性和可访问性。了解链接的不同类型有助于正确地管理变量和函数的作用范围和生命周期。C 中有三种主要的链接：无链接、内部链接和外部链接
  链接（Linkage）是指标识符（变量或函数）在其他作用域中被引用的能力。如果在多个作用域中声明了具有相同标识符的变量或函数，但并非在所有作用域中都能被引用，那么就会生成该变量的多个实例。以下是被认可的链接类型
  - 无链接 (No Linkage)
  - 定义：只能从其所在的作用域指代该变量或函数，即该标识符在其所在的块内是唯一的，外部无法访问
  - 适用对象：所有未声明为 extern 的块作用域变量。所有函数形参。所有并非函数或变量的标识符（例如 typedef、enum 常量等）
  - 
  - 内部链接 (Internal Linkage)
  - 定义：能从当前翻译单元（即源文件）中的所有作用域指代该函数或变量，但不能被其他翻译单元访问
  - 适用对象：所有声明为 static 的文件作用域变量和函数。从 C23 起，所有声明为 constexpr 的文件作用域变量
  - 
  - 外部链接 (External Linkage)
  - 定义：能从整个程序的任何翻译单元（即不同的源文件）指代该变量或函数
  - 适用对象：所有未声明为 static 或 constexpr 的文件作用域变量。所有未声明为 static 的文件作用域函数。所有块作用域函数声明。所有声明为 extern 的变量或函数，如果在该位置没有某个之前的带有内部链接的声明可见
  
  试探性定义 (Tentative Definition)
  6、定义：当声明一个变量而不定义其值时，如果该变量在同一翻译单元中有多个不同的链接声明（例如一个声明为 extern，另一个不带 extern），则行为未定义
  - int x;                // 外部链接（试探性定义）
  - static int x = 5;     // 内部链接
  - // 行为未定义，因为同一标识符 x 具有内部和外部链接

  无链接：变量或函数只能在其定义的块内访问。典型对象包括块作用域的非 extern 变量和函数形参
  内部链接：变量或函数只能在定义它们的翻译单元内访问。典型对象包括 static 文件作用域变量和函数
  外部链接：变量或函数可以在整个程序的任何翻译单元内访问。典型对象包括未声明为 static 或 constexpr 的文件作用域变量和函数、所有声明为 extern 的变量或函数
  理解链接的不同类型有助于正确地管理变量和函数的作用范围，从而避免命名冲突和意外的行为
  
  链接与库
  7、在 C 语言中，链接（linkage）与库的使用紧密相关，特别是当我们在多个源文件之间共享变量和函数时。理解如何在头文件和源文件中声明和定义带有不同链接类型的对象，对模块化和库的开发至关重要
  具有外部链接的声明通常在头文件中提供，以便所有包含该头文件的翻译单元可以引用在其他地方定义的相同标识符
  在头文件中出现的任何具有内部链接的声明都会在每个包含该文件的翻译单元中产生一个单独且不同的对象
  - 带外部链接的声明
  - 定义：带外部链接的声明允许在多个翻译单元（源文件）之间共享同一变量或函数。这种声明通常放在头文件中，以便所有包含该头文件的源文件都能访问这些声明
  - 头文件作用：头文件（.h 文件）通常包含变量和函数的声明，而不包含它们的定义。这确保了变量和函数的实际定义只出现一次（通常在一个源文件中），但可以在多个源文件中引用
  - // 头文件 example.h：
  - // // 声明具有外部链接的变量和函数
  - // extern int globalVar;
  - // void globalFunction();
  - // 
  - // 源文件 example.c：
  - // #include "example.h"
  - // // 定义具有外部链接的变量和函数
  - // int globalVar = 42;
  - // void globalFunction() {
  - //   // 函数实现
  - // }
  - // 另一个源文件 main.c：
  - // #include "example.h"
  - // int main() {
  - //   globalVar = 100;   // 访问具有外部链接的变量
  - //   globalFunction();  // 调用具有外部链接的函数
  - //   return 0;
  - // }
  - 在上面的例子中，globalVar 和 globalFunction 在 example.h 中声明，具有外部链接。这使得任何包含 example.h 的源文件都可以访问和使用它们的定义
  -
  - 带内部链接的声明
  - 定义：带内部链接的声明使得变量或函数只能在单个翻译单元（源文件）内访问。如果将内部链接的声明放在头文件中，每个包含该头文件的源文件都会创建一个独立的对象或函数副本
  - 头文件作用：在头文件中声明具有内部链接的变量或函数意味着每个包含该头文件的源文件都会生成独立的实例，这在许多情况下是不期望的
  - // 头文件 example_internal.h：
  - // // 声明具有内部链接的变量和函数
  - // static int internalVar;
  - // static void internalFunction();
  - // 
  - // 源文件 example1.c：
  - // #include "example_internal.h"
  - // static int internalVar = 1;  // 定义内部链接变量
  - // static void internalFunction() {
  - //   // 函数实现
  - // }
  - // void example1Function() {
  - //   internalFunction();  // 访问内部链接的函数
  - // }
  - // 源文件 example2.c：
  - // #include "example_internal.h"
  - // static int internalVar = 2;  // 每个源文件产生一个独立的变量
  - // static void internalFunction() {
  - //   // 函数实现
  - // }
  - // void example2Function() {
  - //   internalFunction();  // 访问内部链接的函数
  - // }
  - 在这个例子中，example_internal.h 中的 internalVar 和 internalFunction 都具有内部链接。每个包含该头文件的源文件都会生成自己的 internalVar 和 internalFunction 的副本，因此 example1.c 和 example2.c 中的 internalVar 和 internalFunction 是独立的，不会互相干扰  
  
  注解
  8、一般通过定义于头文件 <threads.h> 的便利宏 thread_local 使用关键词 _Thread_local (C23前)
  C 语言文法中，typedef 和 constexpr(C23 起) 说明符在形式上列作存储类说明符，但并不指定存储
  auto 说明符还用于类型推断(C23起)
  在文件作用域的 const 且非 extern 的名称在 C 中拥有外部链接（同所有文件作用域的默认情况），但在 C++ 中拥有内部链接

  外部及试探性定义
  9、在 C 语言中，程序的结构由各种声明和定义组成。这些声明和定义可以分为两类：外部声明和内部声明。这里我们重点讨论外部声明
  外部声明的概念 外部声明指的是出现在函数体（即 {} 括起来的代码块）之外的声明。这些声明通常用于定义或声明具有外部链接的变量和函数，也就是说，这些变量和函数在整个程序的各个翻译单元（即经过预处理器处理后包含所有 #include 的源文件）中都是可见的
  外部声明的特点 位置：外部声明位于任何函数之外，可以在文件的顶部或其他函数之间、作用域：外部声明的作用域通常是整个翻译单元，甚至可以在其他翻译单元中使用（通过 extern 关键字）
  - 链接类型：
  - 外部链接：默认情况下，函数和变量具有外部链接，这意味着它们可以在其他翻译单元中被访问
  - 内部链接：使用 static 关键字声明的变量和函数具有内部链接，它们仅在当前翻译单元中可见
  - 
  - 在一个翻译单元（即经过预处理器处理后包含所有 #include 的源文件）的顶层，每个 C 程序都是一系列声明的序列，这些声明用外部链接或内部链接声明函数和对象。这些声明被称为外部声明，因为它们出现在任何函数之外
  - extern int n;                     // 外部声明拥有外部链接
  - int b = 1;                        // 外部定义拥有外部链接
  - static const char *c = "abc";     // 外部定义拥有内部链接
  - int f(void) {                     // 外部定义拥有外部链接
  -   int a = 1;                      // 非外部
  -   return b; 
  - }
  - static void x(void) {             // 外部定义拥有内部链接
  - }
  - 用外部声明声明的对象具有静态存储期，因此不能使用 “自动存储类说明符”（auto）或 “寄存器存储类说明符”（register），但自 C23 起 “自动存储类说明符” 可用于类型推断；自 C23 起 “自动存储类说明符” 可用于类型推断。由外部声明引入的标识符具有文件作用域  

  9、试探性定义
  在 C 语言中，"试探性定义"是一个重要的概念，特别是当涉及到变量的声明和定义时。这个概念有助于理解在同一个翻译单元（翻译单元是指经过预处理后包含所有 #include 的源文件）中的变量是如何被处理的 
  试探性定义的概念 试探性定义（tentative definition）是指没有初始化器的外部变量声明，且要么没有存储类说明符，要么带有 static 说明符
  - 特点：
  - 没有初始化器：即声明时没有赋初值
  - 可以有 static 说明符：如果使用 static 关键字，变量具有内部链接（仅在当前翻译单元中可见）
  - 可能表现为定义，也可能表现为声明：这取决于在同一翻译单元中是否存在实际的（完全的）定义
  -
  - 试探性定义的处理
  - 如果在同一翻译单元中存在实际的定义（即带有初始化器的定义），试探性定义就仅表现为声明
  - 如果没有找到实际的定义，则试探性定义最终会被视为定义，并且变量会被隐式初始化为零
  - 
  - 试探性定义是可能或可能不表现为定义的声明
  - 若在同一翻译单元的前方或后方能找到实际的外部定义，则试探性定义仅表现为声明
  - 若在同一翻译单元中无定义，则试探性定义表现为将对象空初始化的实际定义
  - 不同于 extern 声明（如果前一声明已建立标识符链接， extern 声明不更改链接），试探性定义可以与同一标识符另一声明的链接不一致。若同一标识符的二个声明均在作用域内且拥有不同链接，则行为未定义
  - 拥有内部链接的试探性定义必须拥有完整类型
  - 
  - int i1 = 1;        // 定义，外部链接
  - int i1;            // 试探性定义，表现为声明，因为 i1 已定义，若在同一翻译单元的前方或后方能找到实际的外部定义，则试探性定义仅表现为声明
  - extern int i1;     // 声明，引用前面的定义
  - 
  - extern int i2 = 3; // 定义，外部链接
  - int i2;            // 试探性定义，表现为声明，因为 i2 已定义，若在同一翻译单元的前方或后方能找到实际的外部定义，则试探性定义仅表现为声明
  - extern int i2;     // 声明，引用到前面的外部链接定义
  - 
  - int i3;            // 试探性定义，外部链接，若在同一翻译单元中无定义，则试探性定义表现为将对象空初始化的实际定义
  - int i3;            // 试探性定义，外部链接
  - extern int i3;     // 声明，外部链接 // 在此翻译单元中，如同以“ int i3 = 0; ”方式定义 i3
  - 
  - static int i4 = 2; // 定义，内部链接
  - int i4;            // 未定义行为：链接与前一行不一致，若同一标识符的二个声明均在作用域内且拥有不同链接，则行为未定义
  - extern int i4;     // 声明，引用到内部链接定义
  - 
  - static int i5;     // 试探性定义，内部链接
  - int i5;            // 未定义行为：链接与前一行不一致，若同一标识符的二个声明均在作用域内且拥有不同链接，则行为未定义
  - extern int i5;     // 引用到前者，其链接为内部
  - 
  - static int i[];    // 错误：试探性 static 声明中的不完整类型，拥有内部链接的试探性定义必须拥有完整类型
  - int i[];           // OK：等价于 int i[1] = {0}; 除非在此文件之后重声明

  10、唯一定义规则
  每个翻译单元可以具有零个或一个具有内部链接（static全局）的每个标识符的外部定义
  这意味着在一个翻译单元中，每个静态全局变量或函数最多只能有一个定义。例如，不能在同一个文件中多次定义相同名称的 static 变量或函数
  
  如果具有内部链接的标识符用于非 VLA、（自C99起）、non-VLA、sizeof、_Alignof（自C11起）、_Alignof或 typeof（自C23起）或 typeof 以外的任何表达式中，则该标识符在翻译单元中必须有且只有一个外部定义
  这就是说，如果你在使用 sizeof、_Alignof 或 typeof 时，使用了一个具有内部链接的标识符，这个标识符在该翻译单元中必须有且有一个明确的定义

  整个程序可以有零个或一个具有外部链接的每个标识符的外部定义
  对于具有外部链接的标识符（即非 static 的全局变量和函数），在整个程序（所有翻译单元的总和）中，每个标识符最多只能有一个定义

  如果具有外部链接的标识符用于非 VLA、（自C99起）、non-VLA、sizeof、_Alignof（自 C11 起）、_Alignof或 typeof（自 C23 起）或 typeof 以外的任何表达式中，则该标识符必须有一个且只有一个外部定义在整个程序中的某个位置
  这意味着在整个程序中，如果使用 sizeof、_Alignof 或 typeof 表达式涉及到一个外部链接的标识符，那么这个标识符在程序中必须且只能有一个定义
  // File1.c
  int globalVariable;                       // 外部链接标识符
  static int staticVariable;                // 内部链接标识符
  // File2.c
  extern int globalVariable;                // 外部链接标识符声明
  static int anotherStaticVariable = 30;    // 内部链接标识符
  // 外部链接标识符的定义 globalVariable 在 File1.c 中定义并初始化。在 File2.c 中，通过 extern 声明引用这个全局变量。全局变量在整个程序中只能有一个定义
  // 内部链接标识符的定义 在 File1.c 中，staticVariable 是一个内部链接标识符，只能在 File1.c 中使用，在 File2.c 中，anotherStaticVariable 是另一个内部链接标识符

  11、注解
  不同翻译单元中的内联定义不受一个定义规则的约束。有关内联函数定义的详细信息，请参阅 inline 
  内联函数（inline functions）是一种提示编译器在调用函数时将函数代码直接替换到调用点，以避免函数调用的开销。与普通函数不同，内联函数的定义在不同的翻译单元中并不受"一个定义"规则的约束。这意味着你可以在多个翻译单元中定义相同的内联函数，而不会导致重复定义错误
  // File1.c
  inline void myFunction() {
    // Function implementation
  }
  // File2.c
  inline void myFunction() {
    // Same function implementation
  }

  关键词 extern 与文件作用域中声明在一起的含义，见存储期及链接
  extern 关键字用于声明一个变量或函数是在其他地方定义的，并且可以在当前文件中使用。它通常用于在头文件中声明全局变量或函数，使得它们能在多个翻译单元中共享
  // header.h
  extern int sharedVariable;
  // File1.c
  #include "header.h"
  int sharedVariable = 10; // 定义变量
  // File2.c
  #include "header.h"
  void useSharedVariable() {
    sharedVariable = 20; // 使用变量
  }  

  有关声明和定义之间的区别，请参阅定义
  声明（declaration）告诉编译器变量或函数的名称和类型，但不分配存储空间或提供实现。例如，extern 声明和函数原型都是声明
  定义（definition）不仅告诉编译器变量或函数的名称和类型，还分配存储空间或提供实现
  extern int globalVariable;      // 声明
  int globalVariable = 10;        // 定义

  发明试探性定义是为了标准化各种 C89 前的前置声明具有内部链接标识符的手段
  试探性定义（tentative definition）概念的引入是为了标准化在 C89 之前不同编译器处理具有内部链接标识符的前置声明的方式。试探性定义允许在没有初始化器的情况下声明变量，并在同一翻译单元中只有一个实际定义
  // File.c
  static int staticVariable;      // 试探性定义
  // ...其他代码...
  static int staticVariable = 10; // 实际定义
  在上面的例子中，static int staticVariable; 是一个试探性定义，而 static int staticVariable = 10; 是实际定义。试探性定义确保在同一翻译单元中，对于具有内部链接的标识符，只有一个最终定义    
  */
  static int z = 30;         // 块作用域，z 是一个静态存储期的局部变量，生命周期为整个程序期间
  struct Examplese { int a; float b; }; // seex1 是一个静态存储期的结构体变量，其成员 a 和 b 也具有静态存储期。同样，如果 seex2 在其他文件中定义，其成员 a 和 b 也将具有外部链接的存储期
  static struct Examplese seex1 = {1, 2.0f};  
  extern struct Examplese seex2;

#endif // STATIC_WORDS  static 关键词  

  return 0;
}