/**
* @file              bitfields.c
* @brief             位域 是 C 语言中的一种特殊结构体成员，用于在结构体或联合体中以位级别
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2024.12.10
* @copyright         Copyright (c) 2024.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2024.12.10 <td>0.1             <td>brightl         <td>位域声明、解释
* </table>
*/
#include "c/basics/variable/variable.h"
#include <stdio.h>

/**
* @brief             声明带有明确宽度的成员，按位数计。相邻的位域成员可能被打包，共享和分散到各个单独的字节
*
* @note              Revision History
*/
#define BITFIELDS
struct S {
  // 通常将占用 4 字节：
  // 5 位： b1 的值
  // 11 位：未使用
  // 6 位： b2 的值
  // 2 位： b3 的值
  // 8 位：未使用
  unsigned b1 : 5, : 11, b2 : 6, b3 : 2;
};
struct S1 {
  // 通常将占用 8 字节
  // 5 位： b1 的值
  // 27 位：未使用
  // 6 位： b2 的值
  // 15 位： b3 的值
  // 11 位：未使用
  unsigned b1 : 5;
  unsigned :0; // 开始新的 unsigned int
  unsigned b2 : 6;
  unsigned b3 : 15;
};

/**
* @brief             位域是C语言中的一种特殊结构体成员，用于在结构体或联合体中以位级别（bit level）来定义数据成员
* @return  int       Return Description
*
* @note              它的使用场景主要是为了节省存储空间或者与硬件寄存器映射的时候，硬件寄存器：位域常用于直接映射硬件寄存器，方便操作特定位，存储优化：通过位域可以精确控制每个成员占用的位数，减少空间浪费
*/
int bitfields_fn(void) {
#ifdef BITFIELDS
  /*
  位域 Bit-fields
  声明带有明确宽度的成员，按位数计。相邻的位域成员可能被打包，共享和分散到各个单独的字节
  位域是C语言中的一种特殊结构体成员，用于在结构体或联合体中以位级别（bit level）来定义数据成员。它的使用场景主要是为了节省存储空间或者与硬件寄存器映射的时候，硬件寄存器：位域常用于直接映射硬件寄存器，方便操作特定位，存储优化：通过位域可以精确控制每个成员占用的位数，减少空间浪费
  
  位域声明，是使用下列 声明符的结构体或联合体的 成员声明
  标识符(可选) : 宽度		
  标识符 正在声明的位域名称。名称是可选的：无名位域引入一个指定的填充位数
  宽度 一个拥有大于或等于零，且小于或等于底层类型位数的整数常量表达式。大于零时，此为此位域将占据的位数。零值仅允许用于无名位域，并拥有特殊含义：它指定结构体定义中的下个位域会从分配单元边界开始
  
  解释
  位域（在 C99 之前）只能有以下三种类型之一，（从 C99 开始到 C23）有四种类型（可能带有 const 或 volatile 限定符）
  unsigned int，用于无符号位域（unsigned int b:3; 的范围是 0..7 ）
  signed int，用于有符号位域（signed int b:3; 的范围是 -4..3 ）
  int 用于具有实现定义的有符号性的位域（注意，这与关键字 int 在其他任何地方的含义不同，在其他地方它的意思是 有符号整数）。例如，int b:3;  可能具有值的范围为 -4..3 或者 0..7
  _Bool 类型，用于单位比特位域（例如 bool x:1;），取值范围为 0 到 1，并且与其进行的隐式转换遵循布尔转换规则(C99 起)
  位精确整数类型（例如，_BitInt (5):4; 范围为 -8..7 而 unsigned _BitInt (5):4; 范围为 0..15））(C23 起)
  其他实现定义的类型可能是可接受的。位域是否可以具有原子类型也是由实现定义的。（自 C11 起）位域中的位数（宽度）设定了它可以容纳的值的范围

  允许将多个相邻位域打包在一起（通常如此）
  struct S {
    // 通常将占用 4 字节：
    // 5 位： b1 的值
    // 11 位：未使用
    // 6 位： b2 的值
    // 2 位： b3 的值
    // 8 位：未使用
    unsigned b1 : 5, : 11, b2 : 6, b3 : 2;
  };

  拥有零 宽度 的特殊无名位域打破填充：它指定下个位域在始于下个分配单元的起点
  struct S {
    // 通常将占用 8 字节
    // 5 位： b1 的值
    // 27 位：未使用
    // 6 位： b2 的值
    // 15 位： b3 的值
    // 11 位：未使用
    unsigned b1 : 5;
    unsigned :0; // 开始新的 unsigned int
    unsigned b2 : 6;
    unsigned b3 : 15;
  };
  因为位域不必在字节的起点开始，故不能取位域的地址。不可能有指向位域的指针。不能对位域使用 sizeof 和 _Alignas (C11 起)，但可以获取包含这些位域的分配单元的地址比如 unsigned 

  注解
  在位域上调用 offsetof 这种用法导致未定义行为
  offsetof是一个宏，用于计算结构体成员相对于结构体起始位置的偏移量。定义在stddef.h中，通常用于获取某个成员在结构体中的偏移量。但是，当试图使用offsetof宏来获取位域成员的偏移量时，会导致未定义行为
  内存布局和对齐：位域的内存布局和对齐方式在不同的编译器和平台上是不同的。位域成员可能会跨越字节边界或者被填充位（padding bits）分隔。这种不确定性使得位域成员的确切位置难以确定
  标准未定义性：C和C++标准没有定义位域成员在内存中的具体布局和对齐方式。因此，使用offsetof宏来获取位域成员的偏移量，会因为其未定义的存储特性而导致不可预测的结果

  保有位域的分配单元的对齐 这种位域的属性未指定
  在位域的背景下，所谓的“分配单元”通常指的是存储位域的基本内存单元（如字节、整型等）。位域的分配单元的对齐方式未指定
  平台依赖：不同的硬件平台和编译器可能会对位域成员进行不同的对齐处理。有的编译器可能会对位域进行字节对齐，有的可能会进行更复杂的对齐方式（如按整型对齐）
  无标准规定：既然C和C++标准没有明确规定位域的对齐属性，编译器有权自行决定如何处理位域的对齐。这会导致跨平台或跨编译器的代码在处理位域时产生不同的行为，增加了代码的不确定性和潜在的bug

  位域的下列属性为实现定义
  int 类型的位域被当做有符号或无符号，即在 C 中，如果你声明一个 int 类型的位域，编译器可以选择将它视为有符号或无符号。这取决于具体的编译器实现
  是否容许除 int、signed int、unsigned int、_Bool(C99 起) 和（可能 unsigned 的）_BitInt(N)(C23 起) 类型的位域，即按照规范，标准位域类型为 int、signed int、unsigned int、_Bool（从 C99 起）和 _BitInt(N)（从 C23 起）。是否允许其他类型的位域取决于编译器实现
  是否容许原子类型的位域(C11 起)，即 C11 引入了原子类型，但是否允许这些原子类型用作位域也是由编译器实现决定的
  位域是否能越过分配单元边界，即一些编译器可能强制每个位域必须完全包含在一个单元内，而另一些编译器可能允许位域跨越单元边界
  分配单元内位域的顺序（一些平台上位域从左往右打包，其他平台上是从右往左），即不同平台可能会以不同的方式存储位域。一些平台从左到右打包位域，另一些平台从右到左

  尽管 _Bool 的对象表示的位数至少为CHAR_BIT，_Bool类型位域的 宽度 不能大于1 (C99起)，即尽管 _Bool 类型的对象表示至少需要 CHAR_BIT 位（通常是 8 位），但在位域中，_Bool 类型的宽度不能超过 1 位
  C++ 编程语言中，位域的宽度能超出底层类型，并且 int 类型的位域始终为有符号，即在 C++ 中，位域宽度可以超过其底层类型的大小，且 int 类型的位域总是被视为有符号的  
  */
  struct Examplebit {
    unsigned int a : 3;  // `a` 占用3位
    unsigned int b : 5;  // `b` 占用5位，可能与 `a` 位域共享同一个字节或存储单元
    unsigned int : 0;    // 强制下一位域（`c`）从新存储单元开始
    unsigned int c : 8;  // `c` 占用8位，从新存储单元开始
  };                     // a 和 b 可能被打包在同一个字节或存储单元中，具体取决于系统架构和编译器实现，由于 unsigned int : 0，c 将从新的存储单元的开始位置开始
  struct Sbit {
    // 三位无符号位域，
    // 允许值为 0..7
    unsigned int b : 3;
  };
  struct Sbit sbit = { 7 };
  ++sbit.b;                               // 无符号溢出
  print_purple("sbit.b = %d\n", sbit.b);  // 输出： 0
  struct Sbt1 {
    // 通常将占用 4 字节：
    // 5 位： b1 的值
    // 11 位：未使用
    // 6 位： b2 的值
    // 2 位： b3 的值
    // 8 位：未使用
    unsigned b1 : 5, : 11, b2 : 6, b3 : 2;
  };
  print_purple("Sbt1 sizeof = %zu\n",sizeof(struct Sbt1)); // 通常打印 4
  struct Sbt2 {
    // 通常将占用 8 字节
    // 5 位： b1 的值
    // 27 位：未使用
    // 6 位： b2 的值
    // 15 位： b3 的值
    // 11 位：未使用
    unsigned b1 : 5;
    unsigned :0; // 开始新的 unsigned int
    unsigned b2 : 6;
    unsigned b3 : 15;
  };
  print_purple("Sbt2 sizeof = %zu\n", sizeof(struct Sbt2)); // 通常打印 8
  print_purple("bit-fields end.\n");

#endif // BITFIELDS bitfields

  return 0;
}