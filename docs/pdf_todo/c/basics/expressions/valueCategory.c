/**
* @file              valueCategory.c
* @brief             brief
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2024.12.28
* @copyright         Copyright (c) 2024.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2024.12.28 <td>0.1             <td>brightl         <td>description
* </table>
*/

#include "c/basics/expressions/expressions.h"
#include "colorfmt.h"
#include <stdio.h>
#include <stdbool.h>

/**
* @brief             brief
*
* @note              Revision History
*/
#define VALUE_CATEGORY

struct Container {
  int arr[3]; // 数组成员
};
// 函数返回一个结构体实例作为右值
struct Container getContainer(void) {
  struct Container c = {{1, 2, 3}};
  return c;
}

// 函数声明
void greet(void);
void greet(void) {
  printf("Hello, World!\n");
}
void farewell(void);
void farewell(void) {
  printf("Goodbye, World!\n");
}

/**
* @brief             brief
* @return  int       Return Description
*
* @note              Revision History
*/
int valueCategory_fn(void) {
#ifdef VALUE_CATEGORY
  /*
  在 C 语言中，每个表达式（带参数的运算符、函数调用、常量、变量名等）具有两个独立的属性：一个类型和一个值类别
  1、每个表达式都属于三种值类别之一：左值、非左值对象（右值）和函数指示符

  左值表达式：
  左值表达式是除类型 void 之外的任何对象类型，且隐含地指代一个对象的表达式（当左值在求值时不实际指代一个对象时，行为未定义）。换言之，左值表达式求值得到对象标识。此值类别的名称（“左值”）是历史性的，并反映了 CPL 中，左值表达式作为赋值运算符的左运算数
  2、在C语言中，左值表达式（lvalue expression）是指那些可以标识内存中特定位置的对象的表达式。当一个表达式求值时，它不仅返回一个值，还隐含地指向了这个值存储的位置。这种表达式的名称“左值”来源于历史上的CPL语言，其中左值表达式可以作为赋值运算符的左侧操作数11。接下来我们将逐句解释并举例说明这些概念
  - 左值表达式的定义 除类型 void 之外的任何对象类型，且隐含地指代一个对象的表达式，这句话的意思是，左值表达式不能是指向 void 类型的数据，因为 void 表示没有类型或不确定类型的值。而其他所有具有确定类型的对象都可以构成左值表达式
  - 当左值在求值时不实际指代一个对象时，行为未定义，如果一个左值表达式在运行时并不真正指向一个有效的内存位置，则其行为是未定义的。例如，试图访问一个已经释放了的动态分配内存区域或者超出数组边界的情况都可能导致未定义行为
  - 左值表达式求值得到对象标识，这意味着左值表达式的求值结果不仅仅是一个值，而是包含了该值所在内存位置的信息
  左值表达式的使用场景语境
  - 作为取址运算符的操作数，只要不是位域或声明为 register 的变量，左值表达式可以用作取地址运算符 & 的操作数
  - 作为前/后自增减运算符的操作数，只有左值表达式才能用作前置或后置自增(++)和自减(--)运算符的操作数，因为这些运算符需要修改对象的内容
  - 作为成员访问（点）运算符的左操作数，结构体或联合体成员可以通过点运算符.来访问，前提是左边的操作数必须是一个左值表达式
  - 作为赋值及复合赋值运算符的左操作数，左值表达式也可以出现在赋值运算符 = 或者复合赋值运算符（如 +=, -= 等）的左侧
  若将左值表达式用于除 sizeof、_Alignof 或上述的运算符之外的语境，则任何完整类型的非数组左值会经历左值转换，这模仿的是从对象位置到其值的内存加载。同样地，在用于除 sizeof、_Alignof、取址运算符或从字符串字面量初始化数组之外的语境时，数组左值会经历数组到指针转换
  - 当左值表达式用于非上述特殊运算符（如 sizeof, _Alignof）的情境下时，会发生所谓的“左值转换”，即从对象的位置信息转换成单纯的值；
  const/volatile/restrict 限定符和原子类型的语义仅应用于左值（左值转换将剥除限定符并移除原子属性）
  - 这些限定符以及原子类型的语义仅应用于左值表达式。一旦发生了左值转换，这些限定属性就会丢失，也就是说，限定符不会影响到最终使用的值本身

  下列表达式是左值：
  - 标识符，标识符是指变量名或函数参数名，只要它们声明为指代对象而不是函数或枚举常量
  - 字符串字面量，从 C99 标准开始，字符串字面量也被认为是左值。然而，它们位于只读内存区域，尝试修改这些字面量会导致未定义行为。因此，虽然技术上是左值，但不应该对它们进行修改
  - (C99) 复合字面量，复合字面量允许创建匿名结构体、联合体或数组，并且可以对其取地址，这意味着它们也是左值
  - 括号表达式，如果一个表达式的无括号版本是左值，那么加上括号后仍然是左值
  - 成员访问（点）运算符的结果，当使用成员访问运算符.时，如果左边的操作数是一个左值，则结果也是一个左值
  - 通过指针访问成员（->）运算符的结果，对于指向结构体或联合体的指针，使用箭头运算符->访问其成员也会产生一个左值
  - 对指向对象指针运用间接使用（一元 *）运算符的结果，应用解引用运算符*到指向对象的指针会得到该对象的位置，即一个左值
  - 下标运算符的结果，数组元素访问会产生左值表达式，允许我们对特定索引处的元素进行读写操作

  可修改左值表达式：一个可修改左值是任何完整的非数组类型的、非 const 限定的左值表达式，而且若它是结构体/联合体，则递归地没有任何成员为 const 限定，只有可修改左值表达式可用作自增减运算符的实参，赋值和复合赋值运算符的左实参
  在C语言中，可修改左值表达式（modifiable lvalue）是指那些不仅标识内存中的位置，而且允许对所标识的对象进行修改的左值表达式。具体来说，一个可修改左值必须满足以下条件
  - 它是一个非 const 限定的完整类型（即不是 void 类型或函数类型）
  - 如果它是结构体或联合体，则该结构体或联合体及其成员都不能被 const 限定符修饰
  - 它不是一个数组类型
  只有可修改左值可以作为自增减运算符（如 ++, --）、赋值运算符（如 =）和复合赋值运算符（如 +=, -= 等）的操作数。这是因为这些操作需要改变对象的内容，而不可修改的左值不允许这样的更改

  非左值对象表达式：
  被称为右值 的非左值对象表达式是对象类型的表达式，它们不表示对象，而是没有对象标识或存储位置的值。不能获取非左值对象表达式的地址
  3、在C语言中，非左值对象表达式（rvalue）是指那些不标识内存中特定位置的对象的表达式。这些表达式通常代表的是临时计算出的值，而不是持久存储的数据。由于它们没有确定的内存位置，因此不能对非左值表达式取地址。以下我们将详细解释并举例说明哪些表达式是非左值对象表达式
  非左值对象表达式的定义：非左值表达式是对象类型的表达式，它不指代对象，而是指代没有对象身份或存储位置的值。这意味着你不能通过这样的表达式来修改底层数据，也不能对其应用取地址运算符&
  下列表达式是非左值对象表达式
  - 整数、字符、浮点数常量：字面量（如整数 42、字符 'A' 或浮点数 3.14）是非左值，因为它们只是具体的数值，并不代表任何实际存在于内存中的变量
  - 所有不返回左值的运算符：函数调用表达式：当函数返回一个对象时，如果这个返回值不是以引用的方式传递，则它是一个右值
  - 转型表达式：类型转换的结果通常是右值，除非它是复合字面量（从 C99 开始支持），后者是左值
  - 作用于非左值结构体/联合体的成员访问（点）运算符：如果结构体或联合体本身是右值，那么即使使用.访问其成员，该成员也是右值
  - 算术、关系、逻辑及位运算符的结果：算术运算符（如加法 +）、关系运算符（如等于 ==）、逻辑运算符（如与 &&）以及位运算符（如按位与 &）的结果都是右值，因为它们产生的结果是临时值
  - 自增和自减运算符的结果：在C语言中，自增和自减运算符（如 x++ 和 x--）产生的是右值，注意前置形式（如 ++x 和 --x）在 C++ 中是左值
  - 赋值及复合赋值运算符的结果：在C语言中，赋值运算符及其复合形式（如 +=, -= 等）的结果是右值。注意这一点与C++不同，在C++中这些运算符的结果可以是左值
  - 条件运算符：条件运算符（?:）注意在 C++ 中，如果第二和第三个操作数为相同类型的左值则为左值
  - 逗号运算符：逗号运算符, 注意：在 C++ 中，如果第二个操作数是左值则为左值
  - 取址运算符，即使它被用一元 * 运算符的结果中和，即取地址运算符&应用于左值时会产生一个指向该左值的指针，但这并不改变原表达式的性质。也就是说，取地址运算符不会将右值变成左值
  - 特殊情况 void 类型表达式：作为特殊情况，void 类型表达式被假设成非左值对象表达式，得出一个不存在表示且不要求存储的值，void 类型表达式被视为非左值对象表达式，因为它表示的是不存在具体表示且不需要存储空间的值

  在C语言中，当一个结构体或联合体包含数组类型的成员，并且该结构体或联合体本身是一个右值时，它实际上代表了一个拥有临时生存期的对象。尽管这个对象整体上是右值，但其内部的数组成员可以通过索引访问（即通过下标运算符[]）或者通过解引用指向该数组的指针来形成左值表达式。这意味着即使整个结构体/联合体是右值，我们仍然能够访问并修改其内部数组成员的内容

  函数指代符表达式：
  函数指代符（由函数声明引入的标识符）是函数类型的表达式。当在异于取址运算符、 sizeof 及 _Alignof（后两者在作用于函数时生成编译错误）的语境中时，函数指代符始终转换成指向函数的非左值指针。注意函数调用运算符是对指向函数指针，而非对函数指代符自身定义的
  3、在C语言中，函数指代符（function designator）是指由函数声明引入的标识符，它代表一个函数。当函数指代符出现在除了取地址运算符&、sizeof及_Alignof之外的上下文中时，它会自动转换为指向该函数的非左值指针。这意味着你不能直接对函数名进行赋值或解引用操作，但可以通过函数名来调用函数
  函数指代符的基本特性
  - 函数指代符是右值：在大多数情况下，函数名作为表达式使用时，会被视为指向函数的指针，并且是一个右值
  - 不可修改：由于它是右值，因此不能对其进行修改，例如不能给函数名赋新值
  - 函数调用：函数调用实际上是通过指向函数的指针完成的，即使看起来像是直接调用了函数名
  理解函数指代符的行为对于正确处理函数指针和回调机制非常重要。在C语言中，函数名本质上是一个特殊的表达式，它可以被当作指向相应函数的指针来使用，但这并不意味着它可以像普通变量那样被修改或解引用。相反，它主要用于函数调用，或者通过取地址运算符显式地创建指向它的指针。此外，应该避免尝试对函数应用 sizeof 或 _Alignof 运算符，因为这样做是没有意义的，并且会导致编译错误
  */
  print_purple("valueCategory start...\n");
  int x = 5;                                       // 2、'x' 是一个左值表达式，这里的 x 是一个整型变量，它既代表了一个具体的数值也代表了该数值在内存中的位置
  int y = 10;                                      // 对左值表达式的求值结果不仅仅是一个值，而是包含了该值所在内存位置的信息，y 的值被用来打印输出，而它的地址则通过取地址运算符 & 获取
  printf("Value of y: %d\n", y);           // 使用y的值
  printf("Address of y: %p\n", (void*)&y); // 使用y的位置
  int z = 20;
  int *pz = &z;                                    // &z 是合法的，因为它指向一个有效的内存位置
  int a = 3;
  a++;                                             // 合法，a 是左值
  // (a + 1)++;                                    // 非法，(a + 1) 不是左值
  struct Point {
    int x;
    int y;
  };
  struct Point p = {1, 2};
  p.x = 10;                                        // 合法，p.x 是左值
  int b = 4;
  b += 6;                                          // 合法，b 是左值
  int arr[5] = {0, 1, 2, 3, 4};
  int first_element = arr[0];                      // arr[0] 是左值，但在这里只关心它的值
  int *ptr = arr;                                  // arr 自动转换为指向第一个元素的指针
  const int c = 7;
  // c = 8; // 错误：c 是常量，不能重新赋值
  int *pc = (int *)&c;                             // 强制转换移除了 const 属性
  *pc = 9;                                         // 编译器允许这样做，但实际行为可能未定义
  int x1 = 5;
  x1 = 10;                                         // 'x1' 是一个左值，可以对其进行赋值操作，这里 x 是一个整型变量，它既代表了一个具体的数值也代表了该数值在内存中的位置
  char *str = "hello";                             // "hello" 是一个字符串字面量
  // str[0] = 'H';                                 // 不要这样做！这将导致未定义行为
  struct Point1 {
    int x, y;
  };
  // 创建一个匿名结构体并对其取地址
  struct Point1 *p1 = &(struct Point1){10, 20};
  p1->x = 30;                                     // 合法：复合字面量是左值
  int a1 = 1;
  (a1) = 2;                                       // 合法：即使有括号，'a1' 依然是左值
  struct Point p2 = {1, 2};
  p2.x = 10;                                      // 合法：p2.x 是左值
  struct Point *ptr1 = &p;
  ptr1->y = 20;                                   // 合法：ptr1->y 是左值
  int value = 42;
  int *ptr2 = &value;
  *ptr2 = 84;                                     // 合法：*ptr2 是左值
  int arr1[3] = {0, 1, 2};
  arr1[1] = 99;                                   // 合法：arr1[1] 是左值
  int x2 = 5;                                     // 'x2' 是一个可修改左值，因为它不是 const，并且是完整的非数组类型
  x2++;                                           // 合法：x2 是可修改左值，可以对其进行自增操作
  struct Point2 {
      int x;
      int y;
  } p3 = {1, 2};
  p3.x = 10;                                      // 合法：p3.x 是可修改左值，可以对其进行赋值操作 
  const int c1 = 7;                               // 'c' 是左值但不可修改，因为它被 const 限定
  // c1++;                                        // 错误：不能对 const 对象使用自增操作
  const struct Point2 cp = {3, 4};
  // cp.x = 5;                                    // 错误：cp.x 是左值但不可修改，因为 cp 被 const 限定
  int arr2[3] = {0, 1, 2};
  // arr2 = {1, 2, 3};                            // 错误：arr2 是数组类型，所以它不是可修改左值
  struct Person {
    char name[20];
    int age;
  };
  struct Person person = {"Alice", 30};
  // person.name 是数组类型，因此不是可修改左值，但是它的元素是可修改的
  person.name[0] = 'B';                          // 合法：person.name[0] 是可修改左值
  // person.age 是可修改左值，因为它既不是 const 限定也不是数组类型
  person.age = 31;                               // 合法：person.age 是可修改左值，可以对其进行赋值操作
  int value1 = 42;
  int * const ptrv1 = &value;                    // 常量指针（如 int * const ptr = &x;）意味着指针本身不能改变，但它指向的对象可以被修改
  *ptrv1 = 84;                                   // 合法：虽然 ptrv1 是常量指针，但它指向的对象是可以修改的
  const int const_value = 99;
  const int *ptrv2 = &const_value;               // 指向常量的指针（如 const int *ptr = &x;）意味着指针指向的对象不能被通过该指针修改，但指针本身可以指向其他对象
  // *ptrv2 = 100;                               // ptrv2 是指向常量的指针，不能修改指向的对象  
  // 原子类型 C11 引入了 _Atomic 类型限定符用于定义原子类型的变量。原子类型的对象只能通过特定的原子操作来访问，它们通常不被视为可修改左值，除非明确指定为可变的

  int x3 = 42;                                   // 42 是一个右值
  char ch3 = 'A';                                // 'A' 是一个右值
  double pi3 = 3.14;                             // 3.14 是一个右值
  // int getValue() {
  //   return 42;
  // }
  // int y1 = getValue();                           // getValue() 的结果是一个右值
  // int *ptr = (int *)0x12345678;                  // 转型表达式的结果是右值
  // struct Point {
  //   int x;
  //   int y;
  // };
  // struct Point getPoint() {
  //   struct Point p = {1, 2};
  //   return p;
  // }
  // int z = getPoint().x;                          // getPoint().x 是右值，如果结构体或联合体本身是右值，那么即使使用.访问其成员，该成员也是右值
  int sum = 3 + 4;                                  // 3 + 4 是右值
  if (a == b) {  }                                  // a == b 是右值
  int bitwise_and = a & b;                          // a & b 是右值
  int aa = 5;
  int bb = a++;                                     // aa++ 是右值
  // ++aa = 10;                                     // 在 C++ 中是左值
  // a++ = 10;                                      // aa++ 是右值
  int cc = 10;
  cc += 5;                                          // cc += 5 是右值
  int d = (true ? 1 : 2);                           // 1 和 2 都是右值
  int e = 1, f = 2;
  f = (e++, f++);                                   // f++ 是右值
  int g = 10;
  int *pg = &g;                                     // &g 是左值
  // void func(void) {
  //   // 函数体内没有返回值
  // }
  // func();                                        // func() 是右值
  printf("Accessing array elements directly:\n");   // 调用函数返回的结构体是右值，getContainer() 函数返回一个 struct Container 类型的对象，这是一个右值
  printf("Element 0: %d\n", getContainer().arr[0]); // 直接访问数组元素，尽管 getContainer() 的返回值是右值，但我们仍然可以使用 getContainer().arr[0] 来直接访问数组的第一个元素。这是因为数组元素的访问操作符 [] 创建了对数组元素的左值表达式
  int (*ptrs)[3] = (getContainer().arr);                    // 使用指针间接访问数组元素，获取数组的地址，可以创建一个指向数组的指针 int (*ptr)[3] 并将其初始化为 &(getContainer().arr)，然后通过解引用这个指针来访问数组的各个元素。这里，(*ptr)[i] 是对数组元素的左值表达式，允许我们读取这些元素的值
  // int (*ptrs)[3] = &(getContainer().arr);
  printf("Accessing via pointer to array:\n");
  printf("Element 0: %d\n", (*ptrs)[0]);            // 解引用指针访问第一个元素
  printf("Element 1: %d\n", (*ptrs)[1]);            // 访问第二个元素
  printf("Element 2: %d\n", (*ptrs)[2]);            // 访问第三个元素
  // int a10[3] = {0};
  // int *a101p = &a10;
  // int (*a10p)[3] = &a10;

  greet();                          // 函数调用，实际上调用的是指向greet的指针，greet 是一个函数指代符，当我们写 greet(); 时，实际上是在通过指向 greet 的指针来调用这个函数
  void (*funcPtr)(void) = greet;    // 函数指针声明并初始化
  funcPtr();                        // 通过指针调用函数，调用 greet 函数
  funcPtr = farewell;               // 修改指针指向另一个函数
  funcPtr();                        // 现在调用 farewell 函数，如何声明和使用函数指针。funcPtr 是一个指向返回类型为 void 且没有参数的函数的指针。我们可以将 greet 或 farewell 的地址赋给 funcPtr，然后通过 funcPtr 来调用相应的函数
  void (*funcPtr1)(void) = &greet;  // 显式获取函数地址，使用 & 操作符
  funcPtr1();                       // 通过指针调用函数
  // 注意，以下两种方式等价：
  // funcPtr();
  // (*funcPtr)();                  // 解引用后再调用，我们既可以直接将函数名赋给函数指针，也可以使用取地址运算符&来显式地获取函数的地址。需要注意的是，在实际调用时，funcPtr() 和 (*funcPtr)() 是等价的，但在某些编译器上可能有不同的风格偏好
  // size_t size = sizeof(greet);      // 编译错误：非法的操作数类型，错误示例：这会导致编译错误
  // alignof(greet);                   // 编译错误：非法的操作数类型

  print_purple("valueCategory end...\n");

#endif // VALUE_CATEGORY  valueCategory 表达式  

  return 0;
}