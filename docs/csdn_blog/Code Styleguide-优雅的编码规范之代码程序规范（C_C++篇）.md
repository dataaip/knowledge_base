## Code Styleguide-优雅的编码规范之代码程序规范（C/C++篇）

关于Code Styleguide-优雅的编码规范 目前已梳理完成了如下三部分：

- 项目目录规范
- 文件结构规范
- 代码程序规范

前两部分已说明项目目录和文件结构的设计规范，建立了项目的基本框架。接下来，代码编写规范将直接影响项目的可维护性、可读性以及团队协作效率。更多可以细节可以参考 [Google 开源项目风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/contents.html)。

---
### 一、代码排版规范说明

代码排版就像写字的笔迹。字迹潦草没人爱看，代码混乱没人想改。整洁的代码排版直接影响可读性和维护性。良好的格式能让代码逻辑清晰，一目了然，方便自己和别人阅读、修改。
#### 1. 缩进规范

缩进是代码的骨架，它清晰展示代码的层次关系（包括函数、条件语句和循环的从属关系），推荐采用以下方式：

缩进单位：统一使用 4个空格 作为缩进单位（禁用制表符）

K&R 花括号风格：左花括号`{` 不换行，紧跟在函数名或 `if/for` 后面

```c
// 函数定义
void func(void) {
    // 缩进4空格，形成视觉层级
}

// 控制语句
if (condition) {
    // ...
} else {
    // ...
}
```

为什么单行代码也要用花括号？
- 防止走光：以后在 `if` 里多加一行代码，不容易出错（忘加花括号会导致第二行代码不受 `if` 控制）
- 避免悬空 `else` 的社死现场，明确告诉 `else` 它属于哪个 `if`
- 用编辑器折叠代码块时更清晰
```c
// 单行逻辑也必须使用花括号 - 防止未来扩展出错
if (error) {
    return FAILURE;
}

// 循环体必须使用花括号 - 避免悬空 else 问题
for (int i=0; i<MAX; i++) {
    process(i);
}
```

#### 2. 空行使用规范

在代码中使用空行可以提升可读性。合理的空行能分隔不同逻辑块，使代码结构更清晰。建议在以下位置添加空行：

代码段落分隔法则：

| 场景         | 空行数 | 作用         |
| ------------ | ------ | ------------ |
| 函数间       | 2行    | 创建视觉隔离 |
| 逻辑段落间   | 1行    | 区分功能模块 |
| 声明与执行间 | 1行    | 隔离不同阶段 |
| 头文件保护宏 | 1行    | 提升可读性   |

留白法则：
- 文件首尾、头文件保护宏保留 1 空行（ EOF 规范）
- 连续空行不超过 2 行

```c
#include <genome.h>

static gene_pool_t shared_pool;  // 全局资源

void gene_expression(void) {

    // 声明区
    rna_strand_t* messenger = NULL;
    amino_acid_t chain[POLYPEPTIDE_MAX];
    
    // 空行分隔声明与执行
    messenger = transcribe_dna(template_strand);
    
    // 空行分隔逻辑块
    if (mature(messenger)) {
        translate_rna(messenger, chain);
    }
}
```

#### 3. 长语句处理规范  

当单行代码超过团队约定的长度限制（建议120字符）时需要适当进行折行，折行的核心目标是在不改变代码逻辑的前提下，提升可读性，避免为了折行而折行，导致代码结构混乱。以下是推荐的折行方式：

120字符黄金法则：超长语句必须换行（建议120字符）

换行位置：遵循自然语义边界

```c
// 运算符换行后置
result = very_long_variable_name1 + very_long_variable_name2 
         + very_long_variable_name3;

// 函数参数换行对齐，函数参数排列（超过三个就换行）  
draw_rectangle(x_position, y_position, 
               width_value, height_value,
               color_red, color_green, color_blue);
```

长语句分段：复杂条件分段、链式调用分段

```c
// 复杂条件分段
if ((temperature > MAX_SAFE_TEMP) 
    && (pressure < CRITICAL_PRESSURE) 
    && (system_state == OPERATIONAL)) {
    emergency_shutdown();
}

// 链式调用分段
result = object->first_method(param1)
             ->second_method(param2)
             ->final_method();
```

折行规范：
- 在自然断点处折行： 比如在运算符（`+`,`-`,`&&`, `||` 等）之后、逗号之后换行
- 换行后对齐： 换行后，新的一行通常比上一行多缩进 4 个空格（或与上一行的同类元素对齐）
- 操作符放行首： 把 `+`、`&&` 这类符号放在新行的开头，一眼就知道这是继续上一行的
- 函数参数太多就换行： 如果一个函数调用参数超过 3 个，就把每个参数单独放一行（或合理分组）
- 禁止在`.`或`->`后换行： 不要把 `object.` 或 `pointer->` 和后面的方法名/成员名分开
#### 4. 空格使用规范

空格是代码排版的重要标点符号，合理使用能让代码结构清晰，逻辑分明，空格应帮助代码逻辑分组，而非随意添加。一致的风格比个人偏好更重要。以下是关键的空格使用规则：

分子间距原则： 

| 场景       | 正确示例                      | 错误示例                     |
| ---------- | ----------------------------- | ---------------------------- |
| 操作符两侧 | `atp = adp + phosphate;`      | `atp=adp+phosphate;`         |
| 逗号后     | `transcribe(template, sense)` | `transcribe(template,sense)` |
| 关键字后   | `while (replication)`         | `while(replication)`         |
| 指针声明   | `nucleotide_t* sequence`      | `nucleotide_t * sequence`    |
| 禁止空格   | `helix[base_index]`           | `helix[ base_index ]`        |

示例说明如下：  

```c
// 操作符示范  
float bmi = weight / (height * height);  // 运算符间保持体面  

// 指针声明防误解指南  
char* buffer = malloc(1024);  // *紧贴类型，远离变量名  

// 函数调用规范  
printf("ID: %d, Name: %s", user_id, user_name); // 逗号后自觉隔离  

// 错误示范：挤得像早高峰地铁  
int x=5*(y+z);  // 操作符亲密无间  

// 正确姿势：保持舒适距离  
int x = 5 * (y + z);  // 每个符号都有独立空间  

// 错误示范：指针立场摇摆  
int * ptr;  // *在中间像墙头草  

// 正确姿势：明确站队  
int* ptr;  // 大声宣告"我是int型指针"  
```

#### 5. 无用代码处理规范 

没用的代码（尤其是被注释掉的旧代码）就是垃圾，必须清理掉！留着只会添乱。

必须删除的代码包含（注释掉的旧代码、调试用的临时代码、永远不会执行的代码块、未被调用的函数/方法）

严禁注释式保留代码：

```c
// ❌ 危险保留（禁止）：
// old_codon_table();
// deprecated_folding_algorithm();

// ✅ 正确做法：
// 1. 立即删除无用代码
// 2. 版本控制系统 git 保留历史记录
// 3. 需要时通过 git blame 追溯
// 4. 利用 IDE 的代码分析功能查找无用代码
// 5. 使用静态分析工具检测无效代码
```

注释代码的三大危害：
- 僵尸代码：注释掉的代码像实验室的过期试剂，占用空间且存在污染风险
- 认知负担：每行无用代码都在消耗队友的脑细胞
- 工具干扰：静态分析工具会被"死代码"误导
#### 6. 空间组织原则 
- 层次性：使用缩进（通常 4空格）表示代码块嵌套层级
- 模块分隔：在逻辑独立的代码段之间插入空行
- 视觉节奏：运算符/分隔符两侧加空格，避免拥挤写法
- 简洁性：及时清除无效代码片段

---
### 二、代码注释

写注释的本质是给代码增加说明文档，目的是让其他人（包括未来的自己）能快速理解代码意图。好的注释应该做到：

- 精准明确：避免模糊描述，需要明确说明代码意图
- 及时更新：随代码变更同步修改，代码改了注释也得改
- 适度精简：只解释必要内容，简单代码无需注释

#### 1. 注释语言

默认使用英文注释：英文是编程领域的通用语言，确保跨国团队协作无障碍

特殊情况用中文：仅当项目成员全是中文母语者且项目有特殊要求时使用

禁止中英混用：同一文件内保持语言统一

#### 2. 注释缩进

注释必须与对应代码保持相同缩进层级

```c
void critical_function(void)
{
    // 安全验证步骤
    if (!safety_check()) {
        // 错误处理流程
        log_error(ERROR_CODE);
    }
}
```

#### 3. 两种注释用法

三种类型的注释用法

|     注释类型      |          使用场景          |         示例          |
| :---------------: | :------------------------: | :-------------------: |
|   单行注释 `//`   |   解释单行或相邻几行代码   | `// 初始化传感器数组` |
| 多行注释 `/* */`  |  文件头说明/复杂算法解释   |  文件开头的功能概述   |
| 文档注释 `/** */` | 函数/类说明（生成API文档） |  函数参数的详细说明   |

举例说明如下  

```c
/* 模块级说明：描述文件/模块功能 */
// 单行注释：解释局部代码

/*
 * 多行注释用于：
 * 1. 复杂算法说明
 * 2. 重要设计决策
 */
```

#### 4. 代码块结束标记

仅当代码块超过50行时添加结束标记

标记应说明结束的是哪个代码块

```c
} // End of while (data_processing)
```
**关键提醒**：如果经常需要这种标记，说明代码块太长（该拆分成小函数了）

#### 5.  非常规操作注释

非常规操作（如故意省略 `break`）必须注释，如 `switch-case` 注释规范等 

避免他人误以为是代码错误：同事以为你忘了写 `break` 偷偷"修复"这个 `bug`

使用 `/* FALLTHROUGH */` 等明确标记

```c
switch (state) {
case STATE_IDLE:
    handle_idle();
    // 故意不break，流转到下一状态
    /* FALLTHROUGH */
case STATE_STARTUP:
    init_system();
    break;
default:
    // 显式标注default处理
    /* UNHANDLED STATE */
}
```

#### 6. 函数注释规范

完整函数注释应包含：功能说明（@brief）、参数说明（@param）、返回值说明（@return）、注意事项（@note）、警告信息（@warning）

```c
/**
 * @brief 读取传感器数据并校准
 * 
 * @param sensor_id 传感器编号 (0-15)
 * @param temp_ptr 温度数据输出指针
 * @param hum_ptr 湿度数据输出指针
 * 
 * @return int 错误代码 (0=成功)
 * 
 * @note 调用前需确保传感器已初始化
 * @warning 非线程安全
 */
int read_calibrated_data(uint8_t sensor_id, 
                        float* temp_ptr, 
                        float* hum_ptr);
```

#### 7. 注释质量检测标准

检查注释是否合格的 3 个问题：
- 时间测试：半年后回看，能 10 秒内看懂吗？（例：为什么用这个算法？）
- 新人测试：新同事只看注释能正确调用函数吗？（例：参数 0-15 是编号还是电压值？）
- 维护测试：改代码时更新注释超过 30 秒吗？（超过说明注释太复杂）

**黄金法则**：好注释解释"为什么"，而不是"是什么"：重点说明设计意图（如为何选择某算法），而非重复代码行为

❌ 差注释：x = x + 1 // 给 x 加 1（代码已说明）
✅ 好注释：x = x + 1 // 补偿传感器误差（见手册 2.3 节）

**终极提示**：当需要大段注释解释代码时，就像用十句话说明怎么开灯——该换更亮的灯泡（重构代码）了！💡

---

### 三、命名规则

命名的黄金法则是：清晰的命名应该直接表明用途，不需要依赖注释来解释含义。

#### 1. 变量与函数命名

全局变量：使用 `g_` 前缀，表明该变量在整个程序中都可访问

静态变量：使用 `s_` 前缀，表明该变量仅在当前文件或函数内有效

局部变量：使用小写字母和下划线组合，不需要特殊前缀

函数名：采用动词+名词结构，明确表达函数执行的操作

布尔值：使用 `is_` 或 `has_` 前缀，直接表示真/假状态

| 类型     | 风格             | 示例                   |
| -------- | ---------------- | ---------------------- |
| 全局变量 | `g_`前缀         | `g_system_state`       |
| 静态变量 | `s_`前缀         | `s_instance_count`     |
| 局部变量 | 小写+下划线      | `buffer_size`          |
| 函数名   | 动词+名词        | `calculate_checksum()` |
| 布尔值   | `is_`/`has_`前缀 | `is_ready`             |

#### 2. 宏与常量命名

宏定义：使用全大写字母和下划线，表明是编译前处理的定义

枚举值：使用全大写字母和下划线，明确标识固定选项值

常量：使用 `k_` 前缀，表明是不可修改的固定值

| 类型   | 风格          | 示例                                |
| ------ | ------------- | ----------------------------------- |
| 宏定义 | 全大写+下划线 | `#define MAX_RETRIES (5)`           |
| 枚举值 | 全大写+下划线 | `enum { MODE_NORMAL, MODE_DEBUG };` |
| 常量   | `k_`前缀      | `const int k_max_users = 100;`      |

#### 3. 命名避坑指南

命名有效性测试：遮盖变量名后阅读代码，若能准确推测出变量名，说明命名合理

|     错误命名     |       问题点       |       正确命名       |
| :--------------: | :----------------: | :------------------: |
|     `int a;`     | 字母a能代表什么？  |     `item_count`     |
|  `void func();`  |   不知道要干什么   | `calculate_salary()` |
|   `bool flag;`   | 什么标志？意义不明 |  `is_authenticated`  |
| `#define num 10` |    宏应该全大写    |     `MAX_ITEMS`      |

---

### 四、其他关键规范

其他关键的规范规则包含结构体字节对齐、变量初始化、浮点数比较、运算符优先级、函数参数限制、宏定义括号规则、宏参数副作用禁止等。

#### 1. 结构体字节对齐

问题：结构体成员顺序不当会导致编译器自动填充空白字节，浪费内存空间。

解决方案：将结构体成员按类型大小降序排列（从大到小）。

效果：减少填充字节，节省内存（示例中从12字节优化到8字节）。

```c
// 错误：未优化布局（可能产生填充字节）
struct BadStruct {
    char c;     // 1 byte
                // 3 bytes padding
    int i;      // 4 bytes
    short s;    // 2 bytes
                // 2 bytes padding
}; // 总大小12字节

// 正确：按大小降序排列
struct GoodStruct {
    int i;      // 4 bytes
    short s;    // 2 bytes
    char c;     // 1 byte
                // 1 byte padding
}; // 总大小8字节
```

#### 2. 变量初始化

原则：声明变量时立即赋予初始值

原因：避免使用未初始化变量导致的随机值错误

应用：基本类型：声明时赋值（如int counter = 0;）、结构体：使用初始化器明确赋值每个成员

```c
// 声明时立即初始化
int counter = 0;
char* buffer = NULL;

// 结构体初始化
struct Config config = {
    .timeout = 1000,
    .retries = 3,
    .mode = DEFAULT_MODE
};
```

#### 3. 浮点数比较

禁止行为：直接用==比较浮点数

原因：浮点数计算存在精度误差，直接比较可能失败

正确方法：比较两数差值的绝对值是否小于误差阈值（如1e-6）

```c
// 禁止直接比较
// if (a == b) { ... }

// 正确方式
#define FLOAT_EPSILON 1e-6
if (fabs(a - b) < FLOAT_EPSILON) {
    // 视为相等
}
```

#### 4. 运算符优先级

风险：复杂表达式依赖默认优先级可能导致计算错误

规范：使用括号明确指定运算顺序

示例：(a << 8) + (b * c)比a << 8 + b * c更安全可靠

```c
// 错误：依赖隐式优先级
result = a << 8 + b * c;

// 正确：显式括号分组
result = (a << 8) + (b * c);
```

#### 5. 函数参数限制

禁止行为：函数直接传递大型结构体

原因：复制大结构体消耗栈空间，可能引发栈溢出

解决方案：改为传递指针（加 const 防止意外修改）

```c
// 禁止：直接传递大结构体
void process_data(struct BigStruct data); // 错误

// 正确：传递指针
void process_data(const struct BigStruct* data_ptr);
```

#### 6. 宏定义括号规则

问题：不带括号的宏可能导致表达式计算错误

示例：SQUARE(x+1) 展开为 x+1\*x+1（错误）

规范：宏的每个参数和整个表达式都加括号、正确示例：((x)*(x))

```c
// 错误：缺少括号保护
#define SQUARE(x) x * x

// 正确：完全括号化
#define SQUARE(x) ((x) * (x))
```

#### 7. 宏参数副作用禁止

风险：宏参数含自增/自减等操作会导致多次求值

示例：INCREMENT(a) * 2 若展开为 (a++)*2 结果不确定

解决方案：用内联函数替代带副作用的宏

```c
// 危险：参数带副作用
#define INCREMENT(x) ((x)++)

int a = 5;
int b = INCREMENT(a) * 2; // 结果依赖求值顺序

// 解决方案：改用内联函数
static inline int increment(int* x) {
    return (*x)++;
}
```

---

### 五、规范执行建议

规范执行包含自动化检查、代码审查要点、文档维护等
#### 1. 自动化检查

核心目的：通过工具自动检测代码是否符合规范

操作说明：在项目配置文件中定义规则（如缩进 4 字符等），工具按配置自动格式化

具体方法：

- 使用 `clang-format` 统一代码排版格式（缩进、换行等）
- 使用 `cppcheck/clang-tidy` 进行静态分析检查潜在代码缺陷

```yaml
# .clang-format 示例
BasedOnStyle: LLVM
IndentWidth: 4
BraceWrapping:
  AfterFunction: true
ColumnLimit: 120
```

#### 2. 代码审查要点

目的：分层检查降低错误合并到主分支的风险

三阶段检查：

- 提交前：开发者自行运行静态分析工具检查
- Review 时：重点审查内存管理、资源释放等高风险问题
- 合并前：验证代码在不同平台/编译器的兼容性

| 审查项    | 检查内容              |
| --------- | --------------------- |
| 提交前    | 运行静态分析工具      |
| Review 时 | 重点检查内存/资源管理 |
| 合并前    | 验证跨平台兼容性      |

#### 3. 文档维护
目的：确保团队成员随时获取最新规范标准及配套工具

存放位置：统一放置在代码仓库根目录

必需文档：

- `CODING_STANDARDS.md`：存放完整的编码规范文本
- `.clang-format`：保存代码格式化工具的配置
- `check_rules.py`：提供自动化检查脚本

