# C++ 初始化（Initialization）

来源：cppreference.com

## 初始化概览

| 初始化类型 | 说明 |
|------------|------|
| **默认初始化** | 不提供初始化器时的行为 |
| **值初始化** | 使用空括号 `()` 初始化 |
| **直接初始化** | 使用括号或等号直接初始化 |
| **拷贝初始化** | 使用等号拷贝初始化 |
| **列表初始化** | 使用花括号列表初始化（C++11） |
| **聚合初始化** | 聚合类型的特殊初始化 |
| **引用初始化** | 引用类型的初始化 |
| **静态初始化** | 程序启动时的初始化 |
| **动态初始化** | 运行时的初始化 |

**初始化**在变量构造时提供初始值。

初始值可在声明符的初始化器部分或new表达式中提供。函数调用时也会发生初始化：函数参数和返回值都会被初始化。

---

## 初始化器详解

对于每个声明符，**初始化器**（如果存在）可以是以下形式之一：

### 初始化器语法

| 语法形式 | 说明 |
|----------|------|
| `= expression` | (1) 拷贝初始化语法 |
| `= {}`<br>`= { initializer-list }`<br>`= { designated-initializer-list }` | (2) 聚合初始化语法（C++11前）<br>列表初始化语法（C++11起） |
| `( expression-list )`<br>`( initializer-list )` | (3) 直接初始化语法 |
| `{}`<br>`{ initializer-list }`<br>`{ designated-initializer-list }` | (4) 列表初始化语法（C++11起） |

### 初始化器子句

**初始化器子句**可以是以下形式之一：

| 形式 | 说明 |
|------|------|
| `expression` | (1) 表达式 |
| `{}` | (2) 空初始化器 |
| `{ initializer-list }` | (3) 初始化列表 |
| `{ designated-initializer-list }` | (4) 指定初始化列表（C++20） |

语法(2-4)统称为**花括号包围的初始化列表**。

---

## 初始化语义

### 一、无初始化器情况

- **对象**：默认初始化
- **引用**：程序错误（ill-formed）

### 二、空括号初始化

- **对象**：值初始化（如 `T obj();`）
- **引用**：程序错误

### 三、初始化语义规则

1. **引用初始化**：参见引用初始化章节
2. **对象初始化**：给定对象类型为 `T`：
   - 语法(1)：拷贝初始化
   - 语法(2)：C++11前为聚合初始化，C++11后为列表初始化
   - 语法(3)：直接初始化
   - 语法(4)：列表初始化（C++11起）

### 示例代码

```cpp
#include <string>

std::string s1;           // 默认初始化
std::string s2();         // 注意：这不是初始化！
                          // 实际声明了一个名为s2的函数
std::string s3 = "hello"; // 拷贝初始化
std::string s4("hello");  // 直接初始化
std::string s5{'a'};      // 列表初始化（C++11）

char a[3] = {'a', 'b'};   // 聚合初始化
                          // （C++11后属于列表初始化）
char& c = a[0];           // 引用初始化
```

---

## 非局部变量初始化

所有具有静态存储期的非局部变量在程序启动时初始化，main函数执行前完成（除非延迟）。线程局部变量在线程启动时初始化，线程函数执行前完成。

这两类变量的初始化分为两个阶段：

### 一、静态初始化

静态初始化有两种形式：

#### 1. 常量初始化

如果可能，应用常量初始化：

```cpp
constexpr int x = 42;        // 编译时常量初始化
const double pi = 3.14159;   // 常量初始化
```

#### 2. 零初始化

否则，非局部静态和线程局部变量进行零初始化：

```cpp
int global_var;              // 零初始化为0
double array[100];           // 所有元素零初始化
```

> 💡 **实现细节**：
> - 常量初始化通常在编译时完成，预计算的对象表示存储在程序映像中
> - 零初始化变量放置在程序映像的.bss段，不占用磁盘空间，由OS加载时清零

### 二、动态初始化

静态初始化完成后，非局部变量进行动态初始化：

#### 1. 无序动态初始化

适用对象：
- 类模板静态数据成员
- 变量模板（C++14）
- 非显式特化的变量

初始化顺序不确定，除非程序在变量初始化前启动线程（C++17起为未排序）。

#### 2. 部分有序动态初始化（C++17）

适用对象：内联变量（非隐式或显式实例化的特化）。

如果部分有序变量V在每个翻译单元中都定义在有序或部分有序变量W之前，则V的初始化排在W之前。

#### 3. 有序动态初始化

适用对象：其他所有非局部变量：

- 单个翻译单元内：按源码中定义顺序严格排序
- 不同翻译单元间：静态变量初始化顺序不确定
- 不同翻译单元间：线程局部变量初始化未排序

> ⚠️ **异常处理**：
> 如果具有静态或线程存储期的非局部变量初始化通过异常退出，调用`std::terminate`。

---

## 高级初始化特性

### 一、早期动态初始化

编译器允许将需要动态初始化的变量作为静态初始化的一部分（编译时初始化），如果满足：

1. 动态初始化版本在初始化前不改变任何命名空间作用域对象的值
2. 静态初始化版本产生的值与动态初始化相同（假设所有非必需静态初始化的变量都动态初始化）

```cpp
inline double fd() { return 1.0; }

extern double d1;
double d2 = d1;   // 未指定：
                  // 如果d1动态初始化，则动态初始化为0.0
                  // 如果d1静态初始化，则动态初始化为1.0
                  // 或静态初始化为0.0（因为这是动态初始化时的值）

double d1 = fd(); // 可能静态或动态初始化为1.0
```

### 二、延迟动态初始化

实现可定义动态初始化是在main函数（或线程函数）第一条语句前发生，还是延迟到之后发生。

#### 延迟规则：

1. **非内联变量**（C++17）：延迟初始化在其翻译单元中定义的任一静态/线程局部变量的首次ODR使用前发生
2. **内联变量**（C++17）：延迟初始化在该特定变量的首次ODR使用前发生

```cpp
// ============ 文件1 ============
#include "a.h"
#include "b.h"

B b;
A::A() { b.Use(); }

// ============ 文件2 ============
#include "a.h"
A a;

// ============ 文件3 ============
#include "a.h"
#include "b.h"

extern A a;
extern B b;

int main() {
    a.Use();
    b.Use();
}

// 如果a在进入main前初始化，b在A::A()使用它时可能仍未初始化
// （因为跨翻译单元的动态初始化顺序不确定）
// 如果a在main第一条语句后初始化（触发文件1的动态初始化），
// 则b会在A::A中使用前初始化
```

---

## 静态局部变量

局部（块作用域）静态和线程局部变量的初始化参见[静态块变量](https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables)。

块作用域中具有外部或内部链接的变量声明不允许有初始化器。此类声明必须使用extern且不能是定义。

```cpp
extern int global_var = 42;  // 错误：extern声明不能有初始化器
```

---

## 类成员初始化

非静态数据成员可通过以下方式初始化：

### 一、成员初始化列表

```cpp
class MyClass {
    int x;
    std::string name;
public:
    MyClass(int val, const std::string& n) 
        : x(val), name(n) {  // 成员初始化列表
    }
};
```

### 二、默认成员初始化器（C++11）

```cpp
class MyClass {
    int x = 42;              // 默认成员初始化器
    std::string name{"default"};
public:
    MyClass() = default;     // 使用默认值
    MyClass(int val) : x(val) {}  // 可覆盖默认值
};
```

---

## 扩展知识详解

### 一、初始化分类总结

| 初始化类型 | 语法示例 | 特点 |
|------------|----------|------|
| **默认初始化** | `T obj;` | 无初始化器 |
| **值初始化** | `T obj{};`<br>`T obj = T();` | 零初始化 + 默认构造 |
| **直接初始化** | `T obj(arg);`<br>`T obj{arg};` | 直接调用构造函数 |
| **拷贝初始化** | `T obj = arg;` | 通过拷贝/移动构造函数 |
| **列表初始化** | `T obj{args...};` | 统一初始化语法 |

### 二、列表初始化优势（C++11）

```cpp
// 防止窄化转换
int x = 42.5;    // 可能截断为42
int y{42.5};     // 编译错误！

// 初始化容器
std::vector<int> vec{1, 2, 3, 4, 5};

// 初始化聚合类型
struct Point { int x, y; };
Point p{.x = 1, .y = 2};  // 指定初始化（C++20）
```

### 三、初始化顺序保证

```cpp
// 同一翻译单元内有序
int a = 10;
int b = a + 5;    // 保证a先初始化

// 不同翻译单元间无序
// file1.cpp: int x = func_from_file2();
// file2.cpp: int y = func_from_file1();
// 可能导致未定义行为
```

### 四、初始化与异常安全

```cpp
class SafeClass {
    std::unique_ptr<int[]> data;
public:
    SafeClass(size_t size) 
        : data(std::make_unique<int[]>(size)) {  // 异常安全初始化
    }
};
```

---

## 缺陷报告（Defect Reports）

| 报告编号 | 应用于 | 发布行为 | 修正行为 |
|----------|--------|----------|----------|
| CWG 270 | C++98 | 类模板静态数据成员初始化顺序未指定 | 指定为无序（除显式特化和定义） |
| CWG 441 | C++98 | 静态存储期非局部引用不总在动态初始化前初始化 | 视为静态初始化，在动态初始化前完成 |
| CWG 1415 | C++98 | 块作用域extern变量声明可为定义 | 禁止（此类声明不允许初始化器） |
| CWG 2599 | C++98 | 函数参数在初始化器中求值是否属于初始化不明确 | 确定属于初始化 |

---

## 标准参考文献

### 相关C++标准章节：

- C++23标准
  - 11.10 Initialization
- C++20标准
  - 11.10 Initialization
- C++17标准
  - 11.10 Initialization
- C++14标准
  - 8.5 Initializers
- C++11标准
  - 8.5 Initializers
- C++98/C++03标准
  - 8.5 Initializers

---

## 相关页面

| 页面名称 | 说明 |
|----------|------|
| [拷贝省略] | 返回值优化等优化技术 |
| [转换构造函数] | 用户定义转换 |
| [拷贝构造函数] | 对象拷贝机制 |
| [默认构造函数] | 默认初始化 |
| [explicit说明符] | 防止隐式转换 |
| [移动构造函数] | 移动语义 |
| [new表达式] | 动态内存分配初始化 |
| [C初始化文档] | C语言初始化对照学习 |

---

## 页面信息

- 页面地址：<https://en.cppreference.com/mwiki/index.php?title=cpp/language/initialization&oldid=178911>
- 最后修改时间：2024年12月31日 22:07
- 离线版本获取时间：2025年2月9日 16:39

---

✅ C++初始化系统是语言的核心特性之一，从C语言的简单初始化发展到现代C++的统一初始化语法。掌握各种初始化形式及其语义对于编写安全、高效的C++代码至关重要。特别是C++11引入的列表初始化和C++17的内联变量特性，为大型项目提供了更好的初始化控制和性能优化机会。理解静态初始化与动态初始化的区别，以及跨翻译单元初始化顺序问题，是避免未定义行为的关键。