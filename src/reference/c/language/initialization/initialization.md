# C语言初始化（Initialization）

来源：cppreference.com

## 初始化概览

| 初始化类型 | 说明 |
|------------|------|
| **显式初始化** | 通过初始化器提供初始值 |
| **隐式初始化** | 无初始化器时的默认行为 |
| **空初始化** | 使用空初始化器 {} |
| **标量初始化** | 基本数据类型的初始化 |
| **数组初始化** | 数组类型的初始化 |
| **结构体/联合体初始化** | 复合类型的初始化 |

对象声明可通过**初始化**过程提供初始值。

对于每个声明符，若未省略，初始化器可为以下形式之一：

### 初始化器语法

| 语法形式 | 说明 |
|----------|------|
| `= expression` | (1) 表达式初始化 |
| `= { initializer-list }` | (2) 初始化列表 |
| `= { }` | (3) 空初始化器（C23起） |

其中，`initializer-list` 是以逗号分隔的非空初始化器列表（可选尾随逗号），每个初始化器有以下形式：

### 初始化器元素形式

| 形式 | 说明 |
|------|------|
| `expression` | (1) 表达式 |
| `{ initializer-list }` | (2) 嵌套初始化列表 |
| `{ }` | (3) 空初始化器（C23起） |
| `designator-list = initializer` | (4) 指定初始化（C99起） |

> 📝 **设计符列表**：
> - 数组设计符：`[常量表达式]`
> - 结构体/联合体成员设计符：`.标识符`

### 复合字面量中的初始化列表

初始化列表还可出现在复合字面量中：

```c
(type){ initializer-list }     // C99起
(type){ }                      // C23起
```

---

## 初始化详解

### 一、初始化器说明

初始化器指定存储在对象中的初始值。

#### 1. 显式初始化

提供初始化器时，根据类型分别处理：

- **标量初始化**：基本类型初始化
- **数组初始化**：数组类型初始化
- **结构体初始化**：结构体和联合体类型初始化

#### 2. 隐式初始化

未提供初始化器时：

- **自动存储期**对象：初始化为不确定值（可能是陷阱表示）
- **静态/线程局部存储期**对象：空初始化

#### 3. 空初始化（C23起）

对象显式从 `initializer = {}` 初始化时为空初始化。

在某些情况下，未显式初始化的对象也为空初始化：

- **指针**：初始化为空指针值
- **整数类型**：初始化为无符号零
- **浮点类型**：初始化为正零
- **数组元素**、**结构体成员**、**联合体首成员**：递归空初始化
- **填充位**：全部初始化为零

> 💡 **实现细节**：
> 在空指针值和浮点零具有全零位表示的平台上，静态对象的这种初始化通常通过在程序映像的.bss段中分配来实现。

---

## 重要注意事项

### 一、初始化约束

1. **静态/线程局部对象**：初始化器中的每个表达式必须是常量表达式或字符串字面量
2. **不完整类型对象**：不能使用初始化器
3. **VLA（变长数组）**：不能初始化
4. **块作用域链接对象**：不能使用初始化器

### 二、函数参数初始化

函数参数的初始值通过函数调用参数的赋值建立，而非初始化。

### 三、不确定值使用

使用不确定值作为标准库调用的参数会导致未定义行为。否则，涉及不确定值的任何表达式结果都是不确定值：

```c
int n;  // 不确定值
if (n == n) { /* 可能为假 */ }
int m = n;  // m也是不确定值
```

### 四、与C++的差异

| C语言 | C++语言 | 说明 |
|-------|--------|------|
| 无值初始化构造 | C23前需用`= {0}`模拟 | C23起可用`= {}`实现与C++值初始化相同语义 |
| 不允许空结构体/联合体 | 支持值初始化 | C标准不允許长度为零的数组 |

---

## 初始化分类详解

### 一、标量初始化

```c
int x = 42;              // 整数初始化
double d = 3.14;         // 浮点初始化
char c = 'A';            // 字符初始化
int* ptr = NULL;         // 指针初始化
```

### 二、数组初始化

```c
// 完全初始化
int arr1[3] = {1, 2, 3};

// 部分初始化（未初始化元素为0）
int arr2[5] = {1, 2, 3};  // {1, 2, 3, 0, 0}

// 指定初始化（C99）
int arr3[5] = {[0] = 1, [2] = 3};  // {1, 0, 3, 0, 0}

// 字符串初始化
char str1[] = "Hello";    // {'H','e','l','l','o','\0'}
char str2[10] = "Hello";  // {'H','e','l','l','o','\0',0,0,0,0}
```

### 三、结构体初始化

```c
struct Point {
    int x, y;
    double z;
};

// 顺序初始化
struct Point p1 = {1, 2, 3.14};

// 指定初始化（C99）
struct Point p2 = {.x = 1, .z = 3.14};  // y自动初始化为0

// 嵌套初始化
struct Rectangle {
    struct Point topLeft;
    struct Point bottomRight;
};
struct Rectangle r = {{.x = 0, .y = 10}, {.x = 20, .y = 0}};
```

### 四、联合体初始化

```c
union Data {
    int i;
    double d;
    char str[20];
};

// 只初始化第一个成员
union Data u1 = {42};           // 初始化i为42
union Data u2 = {.d = 3.14};    // 指定初始化d为3.14（C99）
```

---

## 实际应用示例

### 完整示例代码

```c
#include <stdlib.h>

int a[2];  // 静态数组，初始化为{0, 0}

int main(void)
{
    int i;          // 自动变量，不确定值
    static int j;   // 静态变量，初始化为0
    int k = 1;      // 显式初始化为1
    
    // 数组初始化
    int x[] = { 1, 3, 5 };  // 大小为3的数组
    int* p = x;             // 指针初始化为数组首地址
    
    // 结构体数组指定初始化
    struct {int a[3], b;} w[] = {
        [0].a = {1},        // 第一个元素的a数组：{1,0,0}，b：0
        [1].a[0] = 2        // 第二个元素的a[0]：2，其余：0，b：0
    };
    
    // 动态内存分配（局部变量）
    char* ptr = malloc(10);
    free(ptr);
    
    // 错误示例：
    // static char* ptr = malloc(10);  // 静态对象需常量初始化器
    // int vla[n] = {0};               // VLA不能初始化
    
    return 0;
}
```

### C23空初始化示例

```c
// C23新特性
int arr[] = {};              // 空数组初始化
struct Point p = {};         // 结构体空初始化
union Data u = {};           // 联合体空初始化
```

---

## 扩展知识详解

### 一、存储期与初始化关系

| 存储期 | 未初始化 | 显式初始化 |
|--------|----------|------------|
| **自动** | 不确定值 | 按初始化器 |
| **静态** | 0初始化 | 按初始化器（需常量） |
| **线程局部** | 0初始化 | 按初始化器（需常量） |
| **分配** | 不确定值 | malloc后需手动初始化 |

### 二、设计符初始化深入

```c
// 复杂数组指定初始化
int matrix[3][3] = {
    [0][0] = 1, [0][2] = 2,
    [1][1] = 3,
    [2][0] = 4, [2][2] = 5
};
// 结果：{{1,0,2}, {0,3,0}, {4,0,5}}

// 嵌套结构体指定初始化
struct Complex {
    struct Point p;
    int flags;
};
struct Complex c = {
    .p.x = 10,
    .p.y = 20,
    .flags = 0x01
};
```

### 三、复合字面量应用

```c
// 函数参数传递复合字面量
void process_array(int* arr, int size);

process_array((int[]){1, 2, 3, 4, 5}, 5);

// 返回复合字面量（需谨慎使用）
struct Point* create_point(int x, int y) {
    return &(struct Point){.x = x, .y = y};  // 返回临时对象地址！
}
```

### 四、初始化与对齐

```c
// C11对齐说明符与初始化
_Alignas(16) int aligned_arr[4] = {1, 2, 3, 4};
```

---

## 标准参考文献

### 各版本C标准对初始化的定义：

- **C17标准 (ISO/IEC 9899:2018)**
  - 6.7.9 初始化 (p: 100-105)

- **C11标准 (ISO/IEC 9899:2011)**
  - 6.7.9 初始化 (p: 139-144)

- **C99标准 (ISO/IEC 9899:1999)**
  - 6.7.8 初始化 (p: 125-130)

- **C89/C90标准 (ISO/IEC 9899:1990)**
  - 6.5.7 初始化

---

## 相关页面

| 页面名称 | 说明 |
|----------|------|
| [C++初始化文档] | C++语言初始化对照学习 |

---

## 页面信息

- 页面地址：<https://en.cppreference.com/mwiki/index.php?title=c/language/initialization&oldid=147022>
- 最后修改时间：2023年1月26日 10:03
- 离线版本获取时间：2025年2月9日 16:39

---

✅ 掌握C语言初始化机制是编写可靠程序的基础。从简单的标量初始化到复杂的指定初始化，每种形式都有其特定用途和语法规则。特别是C99的指定初始化和C23的空初始化器，为程序员提供了更灵活、更安全的初始化方式。理解不同存储期对象的初始化行为，对避免未定义行为和提高代码质量至关重要。