## compiler 程序编译
- [compiler 程序编译](#compiler-程序编译)
  - [基本概念](#基本概念)
  - [编译过程](#编译过程)
  - [编译工具链](#编译工具链)

### 基本概念
C 程序是一系列文本文件（通常是`头文件`和`源文件`），它们包含一些声明。它们会经过翻译变成可执行程序，在操作系统调用其`主函数`时被执行（除非它自己就是 OS 程序或其他自立程序，这种情况下入口点是实现定义的）。

某些词在 C 程序中拥有特别含义，它们是`关键词`。其他词可用做`标识符`，可用于标识对象、函数、结构体、联合体或枚举的标签，它们的成员，`typedef` 名，`标号`，或者`宏`。

每个标识符（除了宏）仅在程序的一部分中合法，这部分被称为它的`作用域`，并属于四种命名空间之一。一些标识符拥有链接，这会令它们出现于不同作用域或翻译单元时，指代同一实体。

`函数`的定义包含一系列语句和声明，其中有的包含表达式，它指定程序要进行的计算。

`声明`和`表达式`创建、销毁、访问并操作对象。C 中的每个对象、函数及表达式均关联到一种类型。

### 编译过程
- 编译器处理 C 源文件，就像按照以下顺序发生以下阶段一样。实际实现可以组合这些操作或以不同方式处理它们，只要行为相同即可（来源：cppreference）。 
    > `阶段1`: 源代码文件（通常是某种多字节编码（例如UTF-8）的文本文件）的各个字节，`以实现定义的方式映射到源字符集的字符`。特别是依赖于操作系统的行尾指示符被换行符替换。源字符集是一个多字节字符集，其中包括作为单字节子集的基本源字符集，由以下 96 个字符组成。以对应的单字节表示替换三标符。 

    > `阶段2`: 每当反斜杠出现在一行末尾（紧接着换行符）时，反斜杠和换行符都会被删除，将`两个物理源代码行合并为一个逻辑源代码行`。这是单遍操作：以两个反斜杠后跟一个空行结尾的行不会将三行合并为一行。如果非空源文件在此步骤后不以换行符结尾（无论它最初没有换行符，还是以反斜杠结尾），则行为未定义。

    > `阶段3`: `源文件被分解为注释、空白字符序列（空格、水平制表符、换行符、垂直制表符和换页符）和预处理标记`（头文件名：<stdio.h> 或 "myfile.h"、标识符、预处理数字，包括整数常量和浮点常量，但也包括一些非法记号、字符常量与字符串字面量、运算符与标点、不属于任何其他类别的单独非空白字符）、以一个空格字符替换每段注释、保持换行符是否可将非换行的空白符序列缩减成单个空格字符是实现定义的。若已经分析输入为到给定字符为止的预处理记号，则通常将能构成一个预处理记号的最长字符序列处理成下个预处理记号，即这会导致后继分析失败。这常被称为`最大吞噬` (maximal munch)。最大吞噬规则的仅有例外是：头文件名预处理记号仅在 #include 或 #embed (C23 起) 指令中，在 __has_include 和 __has_embed 表达式中 (C23 起)，和 #pragma 指令中的实现定义位置形成。

    > `阶段4`: `执行预处理器`。#include 指令所引入的每个文件都经历阶段 1 到 4，递归执行。此阶段结束时，从源码移除所有预处理器指令。   

    > `阶段5`: 字符常量和字符串文字中的所有字符和转义序列都从源字符集`转换为执行字符集`（可以是多字节字符集，例如 UTF-8，只要阶段 1 中列出的基本源字符集中的所有 96 个字符都具有单字节表示形式）。如果转义序列指定的字符不是执行字符集的成员，则结果是实现定义的，但保证不是空（宽）字符。在某些实现中，此阶段执行的转换可以通过命令行选项来控制：gcc 和clang 使用-finput-charset 来指定源字符集的编码，-fexec-charset 和-fwide-exec-charset 来指定字符串文字和没有编码前缀的字符常量中执行字符集的编码。   

    > `阶段6`: `连接相邻的字符串`字面量。     

    > `阶段7`: `进行编译`对标记进行句法和语义分析，并将其翻译为翻译单元。   

    > `阶段8`: `发生链接`满足外部引用所需的翻译单元和库组件被收集到程序映像中，该程序映像包含在其执行环境（操作系统）中执行所需的信息。    

- 编程机制 C编程的基本策略是，用程序把源代码文件转换为可执行文件。（来源：cprimerplus）。 
    > C编程的基本策略是，用程序把`源代码文件`转换为`可执行文件`（其中包含可直接运行的机器语言代码）。典型的 C 实现通过编译和链接两个步骤来完成这一过程。编译器把源代码转换成中间代码，链接器把中间代码和其他代码合并，生成可执行文件。C 使用这种分而治之的方法方便对程序进行模块化，可以独立编译单独的模块，稍后再用链接器合并已编译的模块。通过这种方式，如果只更改某个模块，不必因此重新编译其他模块。另外，链接器还将你编写的程序和预编译的库代码合并。

    > `中间文件`有多种形式。我们在这里描述的是最普遍的一种形式，即把源代码转换机器语言代码，并把结果放在目标代码文件（或简称目标文件）中（这里假设源代码只有一个文件）。虽然目标文件中包含机器语言代码，但是并不能直接运行该文件。因为目标文件中储存的是编译器翻译的源代码，这还不是一个完整的程序。

    > `目标代码文件`缺失启动代码（startup code）。启动代码充当着程序和操作系统之间的接口。例如，可以在 MS Windows 或 Linux 系统下运行IBM PC 兼容机。这两种情况所使用的硬件相同，所以目标代码相同，但是 Windows 和 Linux 所需的启动代码不同，因为这些系统处理程序的方式不同。目标代码还缺少库函数。几乎所有的C程序都要使用C标准库中的函数。例如，concrete.c 中就使用了 printf（）函数。目标代码文件并不包含该函数的代码，它只包含了使用 printf（）函数的指令。printf（）函数真正的代码储存在另一个被称为库的文件中。库文件中有许多函数的目标代码。

    > 链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这3部分合并成一个文件，即可执行文件。对于库代码，链接器只会把程序中要用到的库函数代码提取出来。

    > 简而言之，目标文件和可执行文件都由机器语言指令组成的。然而，目标文件中只包含编译器为你编写的代码翻译的机器语言代码，可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码。在有些系统中，必须分别运行编译程序和链接程序，而在另一些系统中，编译器会自动启动链接器，用户只需给出编译命令即可。

- 编译过程实践
    > simple-compile-and-link 如图编译过程 
    > ![alt text](../img/compiler-simple-compile-and-link.png)   

    > 预处理（Preprocessing）：预处理器处理源代码中的预处理指令，如#define、#include等。预处理器会将 #include 指令包含的文件内容复制插入到该指令的位置，处理 #define 定义的宏等。预处理后的文件通常以`.i`为后缀。

    > 编译（Compilation）：编译器将预处理后的文件（.i文件）翻译成汇编语言。编译器会检查代码的语法，进行优化，然后生成汇编代码。生成的汇编代码文件通常以`.s`为后缀。

    > 汇编（Assemble）：汇编器将汇编代码转换为机器代码，生成目标文件。目标文件包含了程序的机器代码，但是这些代码可能还不能直接执行，因为它们可能还依赖于其他的目标文件或库。生成的目标文件通常以`.o`（在Unix-like系统中）或`.obj`（在Windows系统中）为后缀。

    > 链接（Linking）：链接器将一个或多个目标文件以及需要的库链接成一个可执行文件或库。链接器会解析目标文件之间的依赖关系，将依赖的目标文件或库链接在一起。如果目标文件之间存在未解决的依赖关系，链接器会报错。 

    > static-and-dynamic-link 如图链接过程    
    > ![alt text](../img/compiler-static-and-dynamic-link.png)

    > 对于外部库的链接，又分为静态链接和动态链接，它们的区别如下：
    > 可以把自己源代码编译后的目标文件（像上图的 main.cpp .obj文件）想象成一个块不完整的拼图，对于外部库文件想象成拼图剩下的部分。

    > 对于静态链接，在最后的链接过程相当于把两块拼图组成完成的"图片"，这个图片就是可执行程序（像上图的 my-app.exe ）.

    > 对于动态链接，这个过程不会将两块拼图完整的拼接在一起，而是给我们自己的"拼图"缺失的位置添加一个上下文信息（包括动态库的查找方式、内存地址等），程序运行的时候，会动态的加载这些库文件并执行这些外部动态库的程序代码等。

    ```c
    // main.c
    #include <stdio.h>
    int main(void){
        printf("hello world\n");
        return 0;
    }
    // 预处理：通过 gcc -E main.c 命令可以看到预处理结果 main.i
    // 编译：通过 gcc -S mian.c 命令可以生成汇编文件 main.s
    // 汇编：通过 gcc -c main.c 命令可以生成文件 main.o
    // 链接：通过 gcc main.o 可以生成 a.out 可执行文件
    ```

### 编译工具链
- 编译工具链（Toolchain）是指一组用于将源代码转换为可执行文件或库的工具和程序。一个典型的编译工具链包括编译器、汇编器、链接器、库和调试器等组件。
    > Windows 平台主要使用微软提供的工具链——MSVC/MinGW。
    ```bash
    # Windows MSVC 与 SDK:

    # MSVC 并不是特指某一个编译、链接器，它实际上是一套工具链合集，包含但不限于了如下的内容：
    # cl.exe 是一个控制 Microsoft C++ (MSVC) C 和 C++ 编译器和链接器的工具。
    # link.exe
    # 包含更多帮助开发调试的运行时、debugger等。
    
    # Windows SDK 除了 MSVC 以外，在 Windows 上进行 C/C+ +应用开发，我们还需要另一块很重要的东西：Windows SDK。Windows SDK 主要提供了在编译链接过程中要使用到的 C、C++ 标准库以及 Windows 平台的库文件、元数据等。如果把 MSVC 理解为工具的话，那么 SDK 更偏向于工具所需要的物料。

    # MSVC 和 Windows SDK 组成了一套开发工具集+运行时，而 VC++ Redist 主要是运行时。开发者在一台Windows机器上，编写源代码并通过 MSVC 提供的编译工具加上 Windows SDK 提供的库文件等，构建成一个可运行的应用。理论上，这个应用在这台Windows 机器上运行一般没有环境问题。然而，当把这个应用分发到客户 Windows 机器上的时候，如果客户机器没有对应运行环境，则大概率会有异常，但我们没有必要让客户机器安装 MSVC工具链和SDK（他们又不需要开发），只需要一个最小的运行环境即可，而 VC++Redist 就承载了这个能力。

    # Visual Studio Installer 或 Visual Studio 20XX 生成工具 安装开发工具、VC++Redist 的 All In One 安装运行环境。
    
    # Windows MinGW: 
    
    # MinGW (最小化 GNU for Windows) 是一个用于 Windows 的自由和开源的软件开发环境，它可以让开发者使用 GCC 等 GNU 工具来构建原生的 Microsoft Windows 应用。MinGW 提供了一组包含 GCC、GNU Binutils 和 GNU Make 等的开发工具。

    # 通过 MinGW 官网下载安装 https://www.mingw-w64.org/downloads/ 即可。
    ```

    > Linux 平台主要是 GCC。
    ```bash
    # 在 Linux 上想要编译构建 C/C++ 应用，我们总是离不开讨论 GCC。首先，GCC 曾经是 GUN C Compiler 的缩写，也就是GUN 的 C 语言编译器，然而随着不断的发展，GCC 已经能够处理 C++、Object-C、Go 语言等语言了，社区对它的定位也更上了一层，所以它现在的全称是 GNU Compiler Collection，即 GNU 编译器集。
    
    # GCC 主要包含一下几部分：
    # gcc-core：即 GCC 编译器，用于完成预处理和编译过程，把 C 代码转换成汇编代码。
    # Binutils ：除 GCC 编译器外的一系列小工具包括了 链接器ld，汇编器as、目标文件格式查看器readelf 等。
    # glibc：包含了主要的 C 语言标准函数库，C 语言中常常使用的打印函数 printf、malloc 函数就在 glibc 库中。
    
    # 到这里，可以很容易看出，GCC工具链 和 MSVC+Windows SDK 这套算是平级的关系，也属于是工具链集，且有比较强的对应关系，比如 gcc-core 与 cl.exe 都属于编译器角色，而 ld 和 link.exe 都属于链接器，glibc 也与 Windows SDK 类似包含标准函数库等。

    # 在 Linux 中使用 GCC 的命令行工具叫 gcc，你可以认为它是一个工具入口命令行。在默认的情况下将一份源代码编译为可执行程序只需要：gcc hello.cpp -o hello 这个过程其实自动包含了至少两步：1、调用内部的 编译器cc，将源代码编译为目标文件；2、调用内部 链接器ld 将链接目标文件和标准函数库文件。同样的，你可以通过给 gcc 命令行参数来控制是否只进行编译而不链接，甚至直接调用 GCC 包含的 cc命令 和 ld命令 来分别手动对文件进行编译和对汇编代码进行链接操作。

    # 在Linux中想要安装 GCC，一般通过包管理工具进行安装即可。例如，在 Debian 系的 Linux 发行版（Debian、Ubuntu等），我们使用 apt-get 来安装：sudo apt-get install gcc；或是在 RedHat 系的 Linux 发行版（RedHat、CentOS等），使用 yum 进行安装：sudo yum install gcc。

    # 有的时候，当我们搜索在 Linux中 如何安装 gcc 的时候，我们一般会看到这样的一个关键词：build-essential，中文翻译过来就是构建基础集，它本身不是一个软件，而是一个工具集，包含了在 Linux 开发程序的一些比较必要的软件包，包括但不限于gcc、g++、make 等。所有一般我们通过命令 sudo apt-get install build-essential 就把 GCC、make 等一键安装了。但是务必注意，build-essential 是 Debian 系 Linux 发行版提供的合集包，如果是 RedHat 系的 Linux 发行版（例如CentOS）是没有的，但是 RedHat 系提供了类似的软件开发合集包 Development Tools ，通过 yum 安装。
    ```

    > MacOS 平台主要使用 Clang 和 LLVM。
    ```bash
    # 在macOS上，我们一般使用 clang/LLVM 体系工具链来进行代码构建。clang/LLVM 有太多优质的文档介绍它的架构体系了，读者可以自行搜索阅读。至于 clang 怎么使用？其实和 GCC 的命令几乎一样：clang test.c -o test。同样的，它也支持相关参数来控制仅编译还是仅链接等操作，不难理解，在 macOS 上，clang/LLVM 相关工具链与上面的 Windows 下的 MSVC+SDK 和Linux 下的 GCC工具链 的层次差不多。

    # 安装 clang/LLVM 工具链和上面 Linux 的 GCC 安装途径比较类似，在 macOS 我们一般不安装单个的 clang 相关工具链。取而代之的，我们都会安装 Command Line Tools 工具合集。这个 tools 就相当于上面的 build-essential 的定位，包含了开发常用工具。当我们安装 Command Line Tools 的时候，不仅仅会把 clang/LLVM 整个工具链安装，同时还会安装包含了诸如svn、git、make、perl 等工具以及库文件等内容。
    ```
- 不同平台的主流编译工具集以及开发工具包，这里我们做一个简单的总结来描述它们的关系。首先，每一个操作系统都有其底层核心的应用编译工具链：
    > 在 Windows 上是 MSVC+Windows SDK，其中 MSVC 主要作为工具提供编译能力，Windows SDK提供编译过程需要的库文件；
    
    > 在 Linux 上是 GCC编译工具链，其中包含的 gcc、cc 以及 ld 等命令工具提供编译构建的能力，glibc 提供构建过程所需要的C/C++ 语言所需的标准库等。另外，在 Linux 编译跟 Linux 平台相关的应用需要单独安装 Linux 的开发库文件以及 Linux 头文件。
    
    > 在 macOS 上是 clang/LLVM编译工具链，它与 Linux 较为类似，通过内部的工具、命令行以及提供的标准库文件等完成构建应用的能力。另外，在 macOS 上编译跟 macOS平台 相关的应用是需要安装 macOS平台 特定的库文件的，不过在 Command Line Tools 安装的时候，就会帮助我们安装了。    