## build 项目构建
- [build 项目构建](#build-项目构建)
  - [构建系统](#构建系统)
  - [跨平台的构建系统](#跨平台的构建系统)
  - [包管理器](#包管理器)
  - [项目架构规范](#项目架构规范)
  - [目录结构规范](#目录结构规范)

### 构建系统  
- 我们会发现工具链整体提供的是比较底层的核心的编译与链接（后简称编译）等功能。对于较为简单的项目，你确实可以直接通过手写命令的方式来调用这些工具来对代码进行编译。比如将一个 main.cpp 编译为可执行文件，一个简单的命令即可：gcc hello.c -o hello 但是请注意，这个例子只是一个文件。随着项目工程越来越复杂，源代码文件越来越多，编译配置项根据场景的不同越来越复杂（例如，Debug 模式和 Release 模式下编译参数不一样）的时候，依然通过直接调用这些命令的时候就会很复杂，我们需要编写大量复杂的命令行才能完成一个复杂项目的编译工作。基于这样的背景，我们诞生了构建系统（Build System）。  
  
- 如何理解构建系统呢？如果把上一节介绍的编译工具链比作炒菜的铲子，把源代码、库文件比作食材，那么最原始的方式，就是人工使用铲子，先炒什么，再放什么调料，再炒什么，最终制作出一盘菜。而构建系统，可以理解为一个炒菜的机器人，它接收炒菜的图纸文件，只要启动以后，就会自己拿着锅铲摆弄食材来制作出一盘菜。当然，即使是炒菜机器人，底层依然用的锅铲和食材，只是炒菜的流程自动化、机器化了。也就是说，构建系统在底层依赖使用的是编译工具链，只是进行了一定的用户友好的抽象，并降低了项目编译的复杂度。  

- 在不同的平台上，构建系统是不一样的。接下来我们就进一步介绍不同平台的构建系统。
    > Windows MSBuild 与 sln、vcxproj
    ```bash
    # 在 Windows 上的构建系统，最主流的是 MSBuild 构建系统。作为编译工具链的上层，它可以调用系统中安装的 MSVC。当然，它需要按照一定的规则逻辑来调用 MSVC，而这个规则逻辑就如同上面比喻中的炒菜机器人的图纸文件一样。一般来说，"图纸"就是xxx.sln 解决方案配置和 xxx.vcxproj 项目工程配置。这些配置文件通常会指明一些关于编译构建的信息，例如项目工程所包含的源文件有哪些；相关库的头文件查找路径、二进制库文件查找路径；不同场景（Debug或Release）下的代码编译方式（是否代码优化，是否移除符号等）。

    # 这个时候，有的读者可能有疑问。我在 Windows 上开发的时候，一直用的 Visual Studio 打开的这些 .sln 和 .vcxproj，没有看到过 MSBuild 的参与呢。实际上，VS 作为 IDE，更大的作用是可视化展示你的项目工程以及集成更多便利的开发工具，当你在 IDE 中编写源码，配置编译选项，其实就在影响 .sln 和 .vsxproj 配置文件。另外，当你按下了 VS 上项目运行/构建的按钮的时候，底层就是在调用 msbuild.exe。
    ```
    > Windows 上的 VS IDE、MSBuild、MSVC 等关系和流程可以用下图简单描述
    > ![alt text](../img/build-windows-msbuild-msvc.png)

    > Linux make 与 Makefile 
    ```bash
    # 在 Linux/Unix 上的构建系统历史最悠久的就是 make 工具，而与之配合的就是 Makefile 配置文件。 Make 是命令行工具，Makefiles 配置文件指明了项目中具有哪些源代码、编译的规则逻辑等信息。 当 make 执行的时候，读取 Makefile 配置文件，生成 GCC 相关的调用命令行，再调用 GCC 的相关命令行工具进行编译构建。构建系统在底层依赖使用的是编译工具链，只是进行了一定的用户友好的抽象，并降低了项目编译的复杂度。
    
    # 与 Windows 上的 MSBuild 体系类似，make 这个命令行工具可以认为与 msbuild.exe 是同一层次，而 Makefiles 配置文件则是与 .sln 和 .vcxproj 文件是一个功能，指明了项目中具有哪些源代码、编译的规则逻辑等信息。
    ```
    > make、GCC 的关系和流程就可以如下描述了
    > ![alt text](../img/build-linux-make-gcc.png)

    > macOS xcodebuild 与 xcodeproj
    ```bash
    # 在 macOS 存在基于 xcodebuild 的构建系统，其核心的命令行工具就是 xcodebuild。这个 xcodebuild 可以理解为与Windows 下的 msbuild 异曲同工。流程也十分类似，也是读取项目配置文件，进行项目编译。只不过项目配置文件变为了.xcodeproj。

    # 此外，macOS 由于其内核包含 Unix BSD 部分，所以在 macOS 操作系统的发展过程中，很多有关 Unix 的工具同样能被使用。在 macOS 上，我们同样可以使用 make + Makefile 的构建系统体系来调用底层的编译器进行项目构建。
    ```
    > macOS、xcodebuild 的关系和流程就可以如下描述了
    > ![alt text](../img/build-macos-xcodebuild-clang.png)

### 跨平台的构建系统  
- 前面介绍了构建系统的能力：允许用户以配置的方式来组织项目，并让构建系统代替用户完成底层编译工具链的调用。然而随着软件工程的发展，有人在实践中发现，不同平台的构建系统，都有自己独有的构建工具和配置，它们并不通用。每当我们在新的一个平台进行项目构建，我们需要针对新平台编写一套属于该平台的构建配置。此外，还要保证某个平台的配置发生了修改，那其他的平台也需要有对应一致的修改，于是维护成本又逐渐上来了。
  
- 面对一致性与可维护性的问题，有人提出这样的解决思路，既然每个平台的构建系统比较成熟了， 那么暂时不考虑重新做一套的跨平台的构建系统，而是换一个角度，提供一个工具并约定一套几乎与平台无关的通用配置。通过工具加上特定的配置，就可以做到。
    > 如果用户希望在 Windows 上构建应用的时候，那么这个工具就基于配置生成一套 msbuild 能够加载的 .sln、.vcxproj 工程配置。于是，我们可以直接使用 msbuild 构建或是用 VS 打开工程开发构建。
    
    > 如果用户希望在 Linux 上基于同样的代码构建 Linux 平台的应用，那么这个工具就利用同一份配置生成一套 make 能够加载的Makefile 配置。于是，在 Linux，我们就可以使用 make 命令来构建这个应用了。
    
    > macOS 同理。

- 基于上述的设想，CMake 面世。与 CMake 搭配的所谓的"通用配置"，就是我们经常见到的 CMakeLists.txt 文件，通过特定的 DSL（领域特定语言），来描述项目结构以及编译规则。CMake 工作流程就是根据 CMakeLists.txt 来生成平台构建系统特定的项目结构和配置。基于上述设想的结果，各个平台的构建系统配置的编写与维护的任务就沉淀到了 CMake 中，减轻用户的一部分开发负担。CMake 是 C++ 中被广泛使用的开源构建系统工具，支持多种编译器和平台。它通过生成本地构建系统（如 Makefiles、Visual Studio 项目文件等）来实现跨平台构建。   
    
    > 简单总结 CMake 与构建系统的关系。
    > ![alt text](../img/build-all-cmake-cmakelists.png)

- 有的时候，我们会从一些项目中看到 ninja（Ninja, a small build system with a focus on speed (ninja-build.org)）这个东西，很多初学者经常会混淆 ninja、make、CMake 等工具之间的关系。请注意，ninja 扮演的角色主要是构建系统，而不是生成构建系统的工具！它和 msbuild、make、xcodebuild 属于同一层次的工具，而 ninja 作为构建系统，同样需要配置，这个配置一般就是 .ninja 文件。同时，ninja 也是跨平台的，也就意味着在前面提到的"那么暂时不考虑重新做一套的跨平台的构建系统"被 ninja 打破这一局面。既然 ninja 也属于构建系统，那么 CMake 也能指定参数生成 ninja 工程。
    
    > 简单的总结出 ninja 构建系统的关系。 
    > ![alt text](../img/build-all-ninja-build.png)

- xmake 即可作为构建系统也可以生成构建系统。Xmake 是一个基于 Lua 的轻量级跨平台构建工具。可以直接阅读官方文档：xmake 既可以作为构建系统来直接调用编译工具链进行项目编译（默认的），同时，还可以作为 CMake 的角色来生成特定的构建项目配置，借用官方的文档来说：我们能够使用它像 Make/Ninja 那样可以直接编译项目，也可以像 CMake/Meson 那样生成工程文件。也就是说即可作为构建系统也可以生成构建系统。    

### 包管理器  
- 在C++ 早期阶段，开发者主要依赖于手动管理库和依赖项。这通常包括下载源代码或预编译的二进制文件，然后将其集成到项目中。这种方式虽然灵活，但容易出错且难以维护。
    > Conan 是一个现代的、跨平台的 C++ 包管理器，旨在解决依赖管理问题。它支持多种构建系统（如 CMake、Autotools、MSBuild 等），并且可以与 CI/CD 管道集成。Conan 提供了一个中央仓库（Conan Center），开发者可以在其中发布和查找包。
    
    > vcpkg 是由微软开发的 C++ 包管理器，专注于简化库的获取和集成。它特别适合 Windows 平台，但也支持 Linux 和 macOS。vcpkg 提供了一个中央仓库，用户可以轻松地安装和管理库。
    
    > 简单描述出项目构建流程。
![alt text](../img/build-project-compiler-build.png)

### 项目架构规范
- C/C++ 项目架构和项目目录规范会根据不同的项目需求和团队习惯有所不同，以下提供一个基本的、通用的指南。
    > 模块化设计: 把系统分解为一些较小的、彼此相互独立的模块，以便于开发与维护。
    
    > 接口抽象: 接口定义应该简洁明了，容易理解，同时应该能够清楚地反映出模块的职责。
    
    > 合理的类设计: 面向对象的设计应当遵循 SOLID 原则（单一职责、开闭原则、里氏替换、接口隔离以及依赖反转）。
    
    > 错误处理: 在设计中应考虑到异常情况的处理，避免出现程序崩溃。
    
    > 日志记录: 设计日志系统以便于追踪错误，同时该系统应能够通过配置轻松开启或关闭。

### 目录结构规范
- 一个典型的 C/C++ 项目目录可能会如下所示：

    ```bash
    /my_project
      /src          // 源代码文件
      /include      // 头文件目录
      /lib          // 静态或动态库文件
      /bin          // 二进制执行文件
      /doc          // 文档和说明
      /test         // 测试代码
      /scripts      // 构建脚本等
      /third_party  // 第三方库和依赖
      Makefile      // 编译脚本
      README.md     // 项目说明文件
    ```
    > 在所有模块中，`src` 和 `include` 可能会进一步划分为更细的模块。
    
    > 此外，持续集成 (`CI`) 和持续部署 (`CD`) 的配置文件，例如 `.travis.yml` 或 `Dockerfile` 等，应根据需要添加到项目的根目录。

- 一般的 C/C++ 工程目录结构：
    ```bash   
    codeMastery/            项目目录结构   
    ├── .vscode/            vscode环境配置   
    └── bin/                项目编译后的二进制文件，可执行文件、动态库文件   
        ├── app/        
        ├── ...      
        └── core/   
    ├── build/              项目构建的中间输出目录   
    ├── cmake/              CMake 相关配置文档   
    ├── config/             项目配置目录       
    ├── dis/                项目可部署的项目，包括各种环境依赖的安装包   
    └── doc/                项目文档   
        ├── app/       
        ├── ...      
        └── core/   
    ├── docker/             项目 docker 环境配置   
    ├── env/                项目环境相关配置   
    └── examples/           项目示例相关代码   
        ├── app/       
        ├── ...      
        └── core/   
    └── include/            项目头文件代码   
        ├── app/      
        ├── ...      
        └── core/   
    └── lib/                项目编译后输出的库文件，静态库   
        ├── app/      
        ├── ...      
        └── core/       
    ├── res/                项目使用的资源文件   
    └── src/                项目的源代码   
        ├── app/      
        ├── ...      
        └── core/       
    └── test/               项目测试案例代码   
        ├── app/       
        ├── ...      
        └── core/   
    └── thirdparty/         项目使用的第三方库   
        ├── boost/    
        ├── fmt/    
        ├── googletest/      
        └── spdlog/   
    ├── todo/               项目 TODO 清单   
    ├── tools/              项目所使用的工具   
    ├── .clang-format       项目自动格式化 C++ 代码配置文件   
    ├── .clang-tidy         项目静态分析 C++ 代码的质量和风格   
    ├── .gitgnore           项目 git 忽略配置   
    ├── .gitmodules         项目 git modules 配置   
    ├── BUILD.md            项目构建文档   
    ├── CMakeLists.txt      项目 CMake 构建的配置文件   
    ├── CMakePresets.json   项目 CMake 预设的配置文件   
    ├── LICENSE             项目的许可证信息   
    └── README.md           项目的基本信息   
    ```
    > `.vscode`: VSCode 的配置文件目录，包含了你的工作环境配置如调试、任务、格式化等。  
    > `bin`: 通常包含编译后的二进制文件，即可执行文件或动态链接库。  
    > `build`: 这个目录常用于存放项目编译的中间文件。  
    > `cmake`: 此目录存放 cmake 构建的配置和脚本文件。  
    > `dist`: 这个目录包含了可部署的项目，包括各种环境依赖的安装包，以及用于运行项目所需要的文件和库。  
    > `doc`: 该目录存放具有说明性质的文档，这些文档解释了项目的各种细节。  
    > `docker`: 如果项目使用 Docker ，这个目录将包含 Dockerfile 和与 Docker 相关的脚本。  
    > `env`: 这个目录通常用来存储与环境配置相关的文件（比如 Python 的 requirements.txt 文件）。  
    > `examples`: 这个目录包含项目的示例代码，仅供参考。  
    > `include`: 这是头文件的目录，包含 C/C++ 的 .h、.hpp 文件等。  
    > `lib`: 这个目录存放项目依赖的开源库。  
    > `res`: 这个目录存放项目的资源文件，如图像、音频等。  
    > `src`: 这个目录存放项目的源代码。  
    > `test`: 这个目录包含用于测试的文件和代码。  
    > `thirdparty`: 这个目录包含项目所依赖的第三方的库和头文件或源文件。    
    > `tools`: 这个目录包含项目提供的工具包。    
    > `.clang-format`: 这是 clang-format 的配置文件，用于自动格式化 C++ 代码。  
    > `.clang-tidy`: 这是 clang-tidy 的配置文件，用于检查 C++ 代码的质量和风格。    
    > `.gitignore`: 这个文件让 Git 知道哪些文件或目录不应该被版本控制。    
    > `.gitmodules`: 这个文件用于存储项目的 Git 子模块。    
    > `Makefile`: 这是 GNU Make 的配置文件，包含了如何构建项目的指南。    
    > `CMakeLists.txt`: 这是 CMake 的配置文件，包含了如何构建项目的指南。    
    > `LICENSE`: 这个文件通常包含项目的许可证信息。  
    > `README.md`: 这个文件包含项目的基本信息，如项目的目的、如何构建项目、如何运行项目等。 
      