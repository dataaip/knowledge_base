# 翻译阶段（Phases of Translation）

## C语言

## 基本概念

C源文件在被编译器处理时，**仿佛**按照以下顺序执行了以下阶段。实际实现可能合并这些步骤或以不同方式处理，只要行为一致即可。

---

### 阶段 1

1) 源代码文件的各个字节（通常是一个文本文件，使用如UTF-8等多字节编码）以实现定义的方式映射到**源字符集**中的字符。特别是，操作系统相关的换行符会被替换为换行字符（`\n`）。

   **源字符集**是一个包含**基本源字符集**作为单字节子集的多字节字符集，基本源字符集包括以下96个字符：

   a) **5个空白字符**：空格、水平制表符、垂直制表符、换页符、换行符  
   b) **10个数字字符**：`'0'` 到 `'9'`  
   c) **52个字母字符**：`'a'` 到 `'z'` 和 `'A'` 到 `'Z'`  
   d) **29个标点符号字符**：`_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '`

2) **三字符组序列（Trigraph sequences）** 被替换为其对应的单字符表示。（**仅在C23之前有效**）

---

### 阶段 2

1) 每当反斜杠出现在行末（紧接换行符），反斜杠和换行符都会被删除，将两个物理源代码行合并为一个逻辑源代码行。这是一个单次操作：以两个反斜杠结尾的行后跟一个空行时，**不会**将三行合并为一行。

```c
#include <stdio.h>

#define PUTS p\
u\
t\
s
/* 行拼接发生在阶段2，而宏在阶段3被分词，阶段4被展开，
   所以上面的宏等价于 #define PUTS puts */

int main(void) {
    /* 使用行拼接调用 puts */
    PUT\
S\
("Output ends here\\
0Not printed"
/* 行拼接后，剩余的反斜杠转义了 0，字符串提前结束 */
);
}
```

2) 如果一个非空源文件在此阶段之后**没有以换行符结尾**（无论是原始没有换行符，还是以反斜杠结尾），其行为是**未定义的**。

---

### 阶段 3

1) 源文件被分解为**注释**、**空白字符序列**（空格、水平制表符、换行符、垂直制表符、换页符）和**预处理标记（preprocessing tokens）**，包括以下内容：

   a) **头文件名**：如 `<stdio.h>` 或 `"myfile.h"`  
   b) **标识符**  
   c) **预处理数字**，包括整型常量和浮点常量，但也包括一些无效标记，如 `1..E+3.foo` 或 `0JBK`  
   d) **字符常量** 和 **字符串字面量**  
   e) **运算符和标点符**，如 `+`、`<<=`、`<%`、`##` 等  
   f) **不属于其他类别的非空白字符**

2) 每个注释被替换为一个空格字符。

3) 换行符保留，是否将非换行空白字符序列压缩为一个空格字符由实现定义。

> **最长匹配规则（Maximal munch）**：如果输入已解析到某个字符为止，下一个预处理标记通常是**能构成预处理标记的最长字符序列**，即使这会导致后续分析失败。这被称为**最大匹配原则**。

```c
int foo = 1;
// int bar = 0xE+foo; // 错误：无效的预处理数字 0xE+foo
int bar = 0xE/*注释扩展为空格*/+foo; // 正确：0xE + foo
int baz = 0xE + foo; // 正确：0xE + foo
int pub = bar+++baz; // 正确：bar++ + baz
int ham = bar++-++baz; // 正确：bar++ - ++baz
// int qux = bar+++++baz; // 错误：bar++ ++ +baz，不是 bar++ + ++baz
int qux = bar+++/*保存注释*/++baz; // 正确：bar++ + ++baz
```

> **例外情况**：**头文件名预处理标记**只能在 `#include` 或 `#embed`（自C23起）指令中、在 `__has_include` 和 `__has_embed` 表达式（自C23起）中，以及在 `#pragma` 指令中实现定义的位置形成。

```c
#define MACRO_1 1
#define MACRO_2 2
#define MACRO_3 3
#define MACRO_EXPR (MACRO_1 <MACRO_2> MACRO_3) // 正确：<MACRO_2> 不是头文件名
```

---

### 阶段 4

1) **预处理器**被执行。

2) 每个通过 `#include` 引入的文件都会递归地经历阶段1到阶段4。

3) 此阶段结束时，所有预处理指令都会从源代码中移除。

---

### 阶段 5

1) **字符常量**和**字符串字面量**中的所有字符和**转义序列**从**源字符集**转换为**执行字符集**（可以是如UTF-8的多字节字符集，只要基本源字符集中的96个字符在执行字符集中有单字节表示）。

   如果某个转义序列所表示的字符不在执行字符集中，则结果是**实现定义的**，但保证不会是空字符（null字符）。

> **注意**：某些实现可以通过命令行选项控制此阶段的转换。例如，GCC和Clang使用：
> - `-finput-charset` 指定源字符集编码  
> - `-fexec-charset` 和 `-fwide-exec-charset` 指定无编码前缀的字符串字面量和字符常量的执行字符集编码（自C11起）

---

### 阶段 6

**相邻的字符串字面量**被拼接。

例如：
```c
"Hello, " "world!" // 等价于 "Hello, world!"
```

---

### 阶段 7

进行**编译**：对标记进行语法和语义分析，并将其翻译为**翻译单元（translation unit）**。

---

### 阶段 8

进行**链接**：收集翻译单元和满足外部引用所需的库组件，生成程序镜像，其中包含在执行环境中运行所需的信息（如操作系统）。

---

## 参考资料

### C23标准（ISO/IEC 9899:2024）：
- 5.1.1.2 翻译阶段（p: TBD）
- 5.2.1 字符集（p: TBD）
- 6.4 词法元素（p: TBD）

### C17标准（ISO/IEC 9899:2018）：
- 5.1.1.2 翻译阶段（p: 9-10）
- 5.2.1 字符集（p: 17）
- 6.4 词法元素（p: 41-54）

### C11标准（ISO/IEC 9899:2011）：
- 5.1.1.2 翻译阶段（p: 10-11）
- 5.2.1 字符集（p: 22-24）
- 6.4 词法元素（p: 57-75）

### C99标准（ISO/IEC 9899:1999）：
- 5.1.1.2 翻译阶段（p: 9-10）
- 5.2.1 字符集（p: 17-19）
- 6.4 词法元素（p: 49-66）

### C89/C90标准（ISO/IEC 9899:1990）：
- 2.1.1.2 翻译阶段
- 2.2.1 字符集
- 3.1 词法元素

---