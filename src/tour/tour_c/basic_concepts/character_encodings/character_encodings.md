## 字符集与编码- C语言基础概念

```text
基本字符集- 基本字符集包含以下95个字符：
代码点        字符名称                字形
U+0009        字符制表符    
U+000B        行制表符    
U+000C        换页符(FF)    
U+0020        空格    
U+0021        感叹号                !
U+0022        引号                  "
U+0023        数字符号              #
U+0025        百分号                %
U+0026        和号                  &
U+0027        撇号                  '
U+0028        左圆括号              (
U+0029        右圆括号              )
U+002A        星号                  *
U+002B        加号                  +
U+002C        逗号                  ,
U+002D        连字符                -
U+002E        句号                  .
U+002F        斜线                  /
U+0030..U+0039 数字零到九           0 1 2 3 4 5 6 7 8 9
U+003A        冒号                  :
U+003B        分号                  ;
U+003C        小于号                <
U+003D        等号                  =
U+003E        大于号                >
U+003F        问号                  ?
U+0041..U+005A 拉丁大写字母A到Z     A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
U+005B        左方括号              [
U+005C        反斜线                \
U+005D        右方括号              ]
U+005E        抑扬符                ^
U+005F        下划线                _
U+0061..U+007A 拉丁小写字母a到z     a b c d e f g h i j k l m n o p q r s t u v w x y z
U+007B        左花括号              {
U+007C        竖线                  |
U+007D        右花括号              }
U+007E        波浪号                ~
与C++不同，U+000A换行符(LF)不包含在基本字符集中。源文件中应有某种方式指示每行文本的结束，文档会将此类行结束指示视为单个换行字符。
基本字符集也称为基本源字符集。

基本执行字符集- 基本执行字符集包含基本字符集的所有成员，以及以下字符：
代码单元        字符
U+0000        空字符
U+0007        响铃
U+0008        退格
U+000A        换行(LF)
U+000D        回车(CR)

对于每个基本执行字符集，成员的值应为非负数且彼此不同。在源和执行基本字符集中，上述十进制数字列表中0之后的每个字符的值应比前一个值大1。U+0000空字符的值为0。
基本执行字符集的每个成员的表示形式都适合一个字节。
在C++中，基本执行字符集也称为基本字面字符集和基本执行宽字符集。

字面编码
字面编码是执行字符集字符到无编码前缀的字符常量或字符串字面值的实现定义映射。它支持将所有基本执行字符集值映射到实现定义的编码中，可能包含多字节字符序列。

以下字符不在基本执行字符集中，但在普通字符常量或普通字符串字面值中需要编码为单字节：
代码点        字符名称        字形
U+0024        美元符号        $
U+0040        商用at符号      @
U+0060        重音符号        `
(自C23起)

宽字面编码
宽字面编码是执行字符集字符到带L前缀的字符常量或字符串字面值的实现定义映射。如果实现未定义__STDC_MB_MIGHT_NEQ_WC__，则对于所有基本执行字符集值，该映射产生与字面编码相同的值。一个或多个值可以映射到扩展执行字符集的一个或多个值。

UTF-8编码用于将执行字符集的字符映射到带u8前缀的字符常量或(自C23起)字符串字面值。

实现定义的编码(直到C23)/UTF-16编码(自C23起)用于将执行字符集的字符映射到带u前缀的字符常量或字符串字面值。

实现定义的编码(直到C23)/UTF-32编码(自C23起)用于将执行字符集的字符映射到带U前缀的字符常量或字符串字面值。
```

---

### C 语言字符集与编码深度解析

#### 1. **基本字符集 (Basic Character Set)**

```c
// 合法基本字符集示例
printf("Hello_World!"); // 包含下划线(U+005F)
int var = 42; // 包含字母和数字
```

- **定义**：C语言源文件中允许出现的95个字符（包括空格和控制字符）
- **作用**：这些字符可以直接出现在C源代码中，编译器能够识别它们
- **组成**：
  - **控制字符**：
    | **代码点** | **名称**       | **功能**                     | **C 表示** |
    |------------|----------------|------------------------------|------------|
    | U+0009     | 水平制表符     | 列对齐                       | `\t`       |
    | U+000B     | 垂直制表符     | 行对齐（现代系统少用）       | `\v`       |
    | U+000C     | 换页符         | 打印机换页                   | `\f`       |
    | U+0020     | 空格           | 单词分隔                     | ` `        |
  
  - **标点与运算符**：
    ```c
    int sum = a + b; // 使用 + (U+002B)
    if (x > y) {...} // 使用 > (U+003E) 和 ( ) (U+0028/U+0029)
    ```
  - **数字**：U+0030-U+0039 (0-9)
  - **字母**：A-Z (U+0041-U+005A)，a-z (U+0061-U+007A)
- **行结束处理**：
- **注意**：U+000A（换行符）不在基本字符集中。这是因为源文件的行结束指示方式因系统而异（例如Windows用CR+LF，Linux用LF），但编译器在预处理阶段会将行结束符统一视为换行符（LF）。
  ```c
  // Windows: CR+LF(\r\n), Linux: LF(\n), Mac Classic: CR(\r)
  // 编译器统一视为 U+000A (LF)
  ```

#### 2. **基本执行字符集 (Basic Execution Character Set)**

```c
printf("Alert\a"); // 响铃(U+0007)
printf("Back\b");  // 退格(U+0008)
```

- **定义**：在程序执行时（运行时）必须支持的字符集合。
- **组成**：
  - 包含基本字符集的所有字符。
  - 添加以下控制字符：U+0000（空字符）、U+0007（响铃）、U+0008（退格）、U+000A（换行）、U+000D（回车）。
- **要求**：
  - 每个字符都有一个非负整数值（即它们的编码值），且这些值互不相同。
  - 数字字符'0'到'9'的编码值必须是连续的，且递增（例如'0'的编码值为48，则'1'为49，以此类推）。
  - 空字符（NUL）的编码值必须为0。
  - **存储**：基本执行字符集中的每个字符必须能够用一个字节（byte）表示。这意味着这些字符的编码值在0到255之间。

- **扩展字符**：
  | **代码点** | **字符** | **功能**               | **C 转义** |
  |------------|----------|------------------------|------------|
  | U+0000     | NUL      | 字符串终止符           | `\0`       |
  | U+0007     | BEL      | 终端响铃               | `\a`       |
  | U+0008     | BS       | 光标左移               | `\b`       |
  | U+000A     | LF       | 换行                   | `\n`       |
  | U+000D     | CR       | 回车                   | `\r`       |

- **编码要求**：
  ```c
  // 数字连续性验证
  assert('1' - '0' == 1); // 标准要求连续编码
  assert('\0' == 0);      // 空字符必须为0
  ```

#### 3. **字面编码 (Literal Encoding)**
```c
char normal_char = '$'; // U+0024 (C23起)
char normal_str[] = "@email"; // U+0040
```
- **定义**：指在编译时，将无前缀的字符常量（如'a'）和字符串字面值（如"abc"）中的字符映射到执行字符集编码的实现定义方式。
- **关键点**：
  - 对于基本执行字符集中的每个字符，编译器必须能够将其映射到一个或多个字节的序列（通常是单字节）。
  - 此外，C23标准要求以下三个字符（尽管不在基本执行字符集中）在普通字符常量和字符串字面值中必须能够用单字节编码：
    - U+0024（美元符号 $）
    - U+0040（商用at符号 @）
    - U+0060（重音符号 `）
  - 注意：这种编码是“实现定义”的，即不同的编译器或平台可能使用不同的编码（如ASCII、EBCDIC等）。但实际中，ASCII是最常见的。

- **实现定义映射**：
  - **ASCII 系统**：直接对应 ASCII 值
    ```c
    'A' → 65, 'a' → 97
    ```
  - **EBCDIC 系统**（大型机）：
    ```c
    'A' → 193, 'a' → 129
    ```
- **C23 新增要求**：
  | **字符** | **代码点** | **示例**       |
  |----------|------------|----------------|
  | $        | U+0024     | `char c = '$'` |
  | @        | U+0040     | `"user@host"`  |
  | `        | U+0060     | `` `backtick` ``|

#### 4. **宽字面编码 (Wide Literal Encoding)**
```c
wchar_t wide_char = L'€'; // 宽字符常量
wchar_t wide_str[] = L"日本語"; // 宽字符串
```
- **宽字面编码**：用于带有`L`前缀的字符常量和字符串字面值（如`L'中'`或`L"中文"`）。这种编码将字符映射到宽字符（通常是`wchar_t`类型）。如果实现没有定义宏`__STDC_MB_MIGHT_NEQ_WC__`，那么对于基本执行字符集中的字符，宽字面编码产生的值应该与字面编码（即普通字符编码）相同。这意味着，在宽字符中，基本字符的编码值在窄字符和宽字符中是一致的（例如，在ASCII中，'A'的窄编码是65，宽字符中也是65）。

- **映射规则**：
  - 基本字符集：与窄编码相同值
  ```c
  assert(L'A' == 'A'); // 通常成立
  ```
  - 扩展字符：实现定义
- **`__STDC_MB_MIGHT_NEQ_WC__` 宏**：
  ```c
  #ifdef __STDC_MB_MIGHT_NEQ_WC__
  // 窄/宽字符编码可能不同
  wchar_t wc = L'α'; // 可能不同于窄编码
  #endif
  ```

#### 5. **Unicode 字面编码**
```c
// UTF-8 编码 (C23)
char8_t u8_char = u8'✓'; 
char8_t u8_str[] = u8"✅检查";

// UTF-16 (C23)
char16_t u16_char = u'😊';
char16_t u16_str[] = u"开心表情";

// UTF-32 (C23)
char32_t u32_char = U'🚀';
char32_t u32_str[] = U"火箭";
```
- **Unicode字面编码**：
  - **u8前缀**：使用UTF-8编码（例如`u8'中'`或`u8"中文"`）。UTF-8是一种多字节编码，字符可能由1到4个字节表示。
  - **u前缀**（自C23起）：用于UTF-16编码。字符可能由1个或2个16位代码单元表示（即可能是1个或2个`char16_t`）。
  - **U前缀**（自C23起）：用于UTF-32编码。每个字符由一个`char32_t`（32位）表示。
- **编码标准**：
  | **前缀** | **编码** | **字符类型** | **大小** |
  |----------|----------|--------------|----------|
  | `u8`     | UTF-8    | `char8_t`    | 1-4字节  |
  | `u`      | UTF-16   | `char16_t`   | 2/4字节  |
  | `U`      | UTF-32   | `char32_t`   | 4字节    |

#### 6. **执行字符集 (Execution Character Set)**
- **定义**：程序执行时使用的字符集。它是基本执行字符集的超集，可能包含更多字符（例如本地化字符、货币符号等）。
- **编码要求**：基本执行字符集中的字符必须用单字节表示，但扩展字符可以使用多字节表示（例如在UTF-8中，非ASCII字符需要2-4个字节）。
- **结构**：
  ```mermaid
  graph LR
    A[执行字符集] --> B[基本执行字符集]
    A --> C[扩展字符集]
    B --> D[单字节编码]
    C --> E[多字节编码]
  ```
- **多字节字符处理**：
  ```c
  char mb_str[] = "日本語"; // 多字节序列
  mblen(mb_str, MB_CUR_MAX); // 获取首字符长度
  ```

#### 7. **编码转换实践**
```c
// 宽窄转换示例
#include <stdlib.h>
#include <locale.h>

int main() {
    setlocale(LC_ALL, "en_US.utf8");
    
    const char* narrow = u8"こんにちは";
    size_t len = mbstowcs(NULL, narrow, 0); // 获取宽字符长度
    wchar_t* wide = malloc((len + 1) * sizeof(wchar_t));
    mbstowcs(wide, narrow, len + 1);
    
    wprintf(L"Wide: %ls\n", wide);
    free(wide);
}
```

#### 8. **平台差异处理**
```c
// 处理编码差异
#if defined(_WIN32)
    #define LINE_ENDING "\r\n"
    #define ENCODING "CP1252"
#elif defined(__unix__)
    #define LINE_ENDING "\n"
    #define ENCODING "UTF-8"
#endif

void write_file() {
    FILE* f = fopen("output.txt", "w");
    fprintf(f, "Content%s", LINE_ENDING);
    fclose(f);
}
```

#### 9. **C23 编码改进**
- **新特性**：
  - `char8_t` 类型：明确 UTF-8 字符
  - 强制 UTF 编码：消除实现定义歧义
  - Unicode 标识符：
    ```c
    int résumé = 1; // C23 允许
    ```

#### 10. **字符集应用场景**
```c
// 1. 协议通信
void send_packet() {
    char packet[] = { STX, 'D','a','t','a', ETX };
    serial_write(packet);
}

// 2. 终端控制
void clear_screen() {
    printf("\033[2J"); // ANSI 转义序列
}

// 3. 本地化输出
void localized_print() {
    setlocale(LC_CTYPE, "ja_JP.utf8");
    wprintf(L"日本語出力\n");
}
```

#### 11. **编码验证技术**
```c
// UTF-8 验证函数
bool is_valid_utf8(const char* str) {
    while (*str) {
        if ((*str & 0x80) == 0) { // 单字节
            str++;
        } 
        else if ((*str & 0xE0) == 0xC0) { // 2字节
            if ((str[1] & 0xC0) != 0x80) return false;
            str += 2;
        }
        // ... 其他情况类似处理
        else return false;
    }
    return true;
}
```

---

### 示例说明

#### 示例1：基本字符集在源代码中的使用
```c
#include <stdio.h>

int main() {
printf("Hello, World!\n"); // 字符串中的字符都在基本字符集中
return 0;
}
```
- 这里，双引号内的字符串包含的字符（H, e, l, o, 逗号, 空格, W, r, d, !）都是基本字符集的成员。换行符`\n`是基本执行字符集的成员，但它在源代码中是以转义序列形式出现的。

#### 示例2：执行字符集和字面编码
假设编译器使用ASCII编码作为字面编码：
```c
char c = 'A'; // 'A'的ASCII值是65，所以c被初始化为65
char s[] = "ABC"; // 字符串的字节序列：65, 66, 67, 0
```
- 这里，字符'A'、'B'、'C'属于基本执行字符集，它们在执行字符集（ASCII）中的编码就是它们的ASCII值。

#### 示例3：宽字符和Unicode字面
```c
#include <stdio.h>
#include <wchar.h>

int main() {
wchar_t wc = L'€'; // 欧元符号，在宽字符中可能是0x20AC（取决于编译器）
char16_t u16c = u'€'; // UTF-16编码，可能是0x20AC
char32_t u32c = U'€'; // UTF-32编码，就是0x000020AC
char u8str[] = u8"€"; // UTF-8编码：0xE2, 0x82, 0xAC

printf("Wide: %lc\n", wc);
return 0;
}
```
- 注意：欧元符号不在基本执行字符集中，所以需要使用宽字符或Unicode字面。

---

### 总结
- **基本字符集**：定义了C源代码中可以直接出现的字符（95个）。
- **基本执行字符集**：程序运行时必须支持的字符集（基本字符集+几个控制字符），要求每个字符用单字节表示，且数字连续，空字符为0。
- **字面编码**：编译器将无前缀的字面值中的字符映射到执行字符集编码的方式（实现定义，通常为ASCII）。
- **宽字面和Unicode字面**：提供对宽字符和Unicode字符的支持，使用不同的前缀（L, u8, u, U）和编码（实现定义的宽字符编码、UTF-8、UTF-16、UTF-32）。

> C 语言的字符处理建立在基本字符集和实现定义的编码映射之上。理解字符集层次（基本源字符集→基本执行字符集→扩展执行字符集）是正确处理文本的基础。C23 通过引入强制 Unicode 编码和 `char8_t` 等类型，显著改善了多语言支持。开发跨平台应用时，必须考虑行结束符和字符编码的差异，使用标准库函数进行转换验证可确保代码健壮性。