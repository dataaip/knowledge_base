/**
* @file              punctuation.c
* @brief             brief
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2025.07.05
* @copyright         Copyright (c) 2025.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2025.07.05 <td>0.1             <td>brightl         <td>description
* </table>
*/

#include <stdio.h>  // 头文件

#define TOUR_C_BASIC_CONCEPTS_PUNCTUATION

/*
### 标点C C 语言 基本概念 
这些是 C 语言中的标点符号。每个符号的含义在链接的页面中有详细说明。

{ }
在 struct 或 union 定义中，分隔 struct-declaration-list。
在枚举定义中，分隔枚举器列表。
分隔复合语句。compound 语句可以是函数定义的一部分。
在初始化中，分隔初始值设定项。

[ ]
下标运算符。
声明或 type-id 中的数组声明符的一部分。
在初始化中，为 array 元素引入一个标号。（自 C99 起）
在属性说明符中，分隔属性。（自 C23 起）

#
引入 preprocessing 指令。
用于字符串化的预处理运算符。

##
用于标记粘贴的预处理运算符。

( )
在表达式中，指示分组。
函数调用运算符。
在 sizeof、_Alignof（C11 起）、typeof 或 typeof_unqual（C23 起）表达式中，分隔作数。
在显式强制转换中，分隔 type-id。
在复合文本中，分隔 type-id。（自 C99 起）
在声明或 type-id 中，指示分组。
在函数声明符（在声明或类型 ID 中）中，分隔参数列表。
在 if、switch、while、do-while 或 for 语句中，分隔控制子句。
在类似函数的宏定义中，分隔宏参数。
在类似函数的宏调用中，分隔宏参数或防止将逗号解释为参数分隔符。
__has_include、 __has_embed 或 __has_c_attribute（自 C23 起）预处理运算符的一部分。defined
泛型选择表达式的一部分。（自 C11 起）
在 _Atomic 类型说明符中，分隔 type-id。（自 C11 起）
在静态断言声明中，分隔作数。（自 C11 起）
在 _Alignas 说明符中，分隔作数。（自 C11 起）
在属性中，分隔属性参数。（自 C23 起）
在位精确整数类型名称 （_BitInt（N）） 中，分隔大小。（自 C23 起）
可变__VA_OPT__宏定义中替换的一部分。（自 C23 起）
在#embed指令和__has_embed预处理表达式，分隔 preprocessor 参数子句。（自 C23 起）

;
指示 的结束
A 语句（包括 for 语句的 init-statement）
声明或 struct-declaration-list
将 for 语句的第二个和第三个子句分开。

:
条件运算符的一部分。
标签声明的一部分。
在 bit-field 成员声明中，引入 width.
引入一个 enum base，它指定 enum 的底层类型。（自 C23 起）
在泛型关联中，分隔 type-id 或违约和所选表达式。（自 C11 起）

...
在函数声明符的参数列表中，表示可变参数函数。
在宏定义中，表示可变参数宏。（自 C99 起）

?
条件运算符的一部分。

::
在属性中，指示属性范围。（自 C23 起）
在预处理器前缀参数（由#embed和__has_embed） 表示范围。（自 C23 起）

.
Member access 运算符。
在初始化中，为 struct/union 成员引入一个标号。（自 C99 起）

->
Member access 运算符。

~
一元补码运算符（又名按位非运算符）。

!
逻辑 not 运算符。

+
一元加运算符。
二进制加运算符。

-
一元减号运算符。
二进制减号运算符。

*
Indirection 运算符。
乘法运算符。
声明符或 type-id 中的指针运算符运算符。
函数声明中可变长度数组声明符长度的占位符。（自 C99 起）

/
除法运算符。

%
Modulo 运算符。

^
按位 xor 运算符。

&
Address-of 运算符。
按位和运算符。

|
按位 or 运算符。

=
简单赋值运算符。
在初始化中，分隔对象和初始值设定项列表。
在枚举定义中，引入枚举常量的值。

+=
复合赋值运算符。

-=
复合赋值运算符。

*=
复合赋值运算符。

/=
复合赋值运算符。

%=
复合赋值运算符。

^=
复合赋值运算符。

&=
复合赋值运算符。

|=
复合赋值运算符。

==
相等运算符。

!=
不等式运算符。

<
小于运算符。
在
一个#include命令
一个__has_include预处理表达式 （自 C23 起）
一个#embed命令 （自 C23 起）
一个__has_embed预处理表达式 （自 C23 起）
#pragma 指令中的实现定义位置

>
大于运算符。
在 中指示标头名称的结尾
一个#include命令
一个__has_include预处理表达式 （自 C23 起）
一个#embed命令 （自 C23 起）
一个__has_embed预处理表达式 （自 C23 起）
#pragma 指令中的实现定义位置

<=
小于或等于运算符。

>=
大于或等于运算符。

&&
逻辑 and 运算符。

||
逻辑 or 运算符。

<<
按位移位运算符。

>>
按位移位运算符。

<<=
复合赋值运算符。

>>=
复合赋值运算符。

++
Increment 运算符。

--
递减运算符。
,
逗号运算符。
中的列表分隔符
声明中的 declarator 列表
初始化中的初始化器列表，包括复合字面量（C99 起）
函数调用表达式中的参数列表
枚举声明中的枚举器列表
函数参数列表
类似函数的宏定义中的宏参数列表
类似函数的宏调用中的宏参数列表，除非位于内部括号集之间
泛型选择表达式中的泛型关联列表（自 C11 起）
属性列表（自 C23 起）
在静态断言声明中，分隔参数。（自 C11 起）
在泛型选择表达式中，将控制表达式和泛型关联列表分开。（自 C11 起）

引用
C23 标准 （ISO/IEC 9899：2024）：6.4.6 标点符号（第 68-69 页）
C17 标准 （ISO/IEC 9899：2018）：6.4.6 标点符号 （p： 52-53）
C11 标准 （ISO/IEC 9899：2011）：6.4.6 标点符号（第 72-73 页）
C99 标准 （ISO/IEC 9899：1999）：6.4.6 标点符号 （p： 63-64）
C89/C90 标准 （ISO/IEC 9899：1990）：3.1.6 标点符号

另请参阅
替代表示法 （C95）	某些运算符的替代拼写
*/

/*
我们面对的是一个关于C语言中标点符号的详细描述。这些标点符号在C语言中扮演着语法结构的关键角色。我将按照要求，深入、完整地解释每个标点符号的用途，并举例说明，最后进行总结。

首先，我们按照标点符号的分类进行解释：

### 1. 花括号 `{ }`
- **用途**：
  - 在结构体（struct）或联合体（union）定义中，包围成员声明列表。
  - 在枚举（enum）定义中，包围枚举常量列表。
  - 包围复合语句（代码块），如函数体、循环体等。
  - 在初始化时，包围初始化列表。
- **示例**：
  ```c
  struct Point { int x; int y; }; // 结构体定义
  enum Color { RED, GREEN, BLUE }; // 枚举定义
  void func() { printf("Hello"); } // 函数体
  int arr[] = {1, 2, 3}; // 数组初始化
  ```

### 2. 方括号 `[ ]`
- **用途**：
  - 数组下标运算符，用于访问数组元素。
  - 在数组声明中，表示数组的维度（可以是常量表达式或省略号表示变长数组）。
  - 在初始化器中，为数组元素指定下标（C99起）。
  - 在属性说明符中，包围属性（C23起）。
- **示例**：
  ```c
  int arr[5]; // 数组声明
  arr[0] = 10; // 下标访问
  int b[3] = { [1]=2, [0]=1, [2]=3 }; // 指定初始化（C99）
  [[noreturn]] void exit(int status); // 属性（C23）
  ```

### 3. 井号 `#`
- **用途**：
  - 引入预处理指令，如`#include`、`#define`等。
  - 在宏定义中，作为字符串化运算符（将宏参数转换为字符串）。
- **示例**：
  ```c
  #include <stdio.h> // 预处理指令
  #define STR(s) #s   // 字符串化，STR(hello)变成"hello"
  ```

### 4. 双井号 `##`
- **用途**：
  - 预处理器的标记连接运算符，用于将两个标记连接成一个。
- **示例**：
  ```c
  #define CONCAT(a, b) a##b
  int xy = 10;
  printf("%d", CONCAT(x, y)); // 输出10，因为连接成xy
  ```

### 5. 圆括号 `( )`
- **用途**：
  - 在表达式中，改变运算优先级（分组）。
  - 函数调用运算符，包围实参列表。
  - 在`sizeof`、`_Alignof`（C11）、`typeof`（C23）等运算符中，包围操作数（当操作数是类型名时）。
  - 在类型转换中，包围目标类型。
  - 在复合字面量中，包围类型名（C99）。
  - 在声明中，用于分组（如函数指针声明）。
  - 在函数声明中，包围形参列表。
  - 在控制语句（if、switch、while、for等）中，包围条件表达式。
  - 在宏定义中，包围宏参数列表或宏参数（防止逗号被解释为参数分隔符）。
  - 在`defined`、`__has_include`等预处理运算符中，包围操作数。
  - 在泛型选择（`_Generic`）中，包围整个表达式和关联列表（C11）。
  - 在`_Atomic`类型说明符中，包围类型名（C11）。
  - 在静态断言（`_Static_assert`）中，包围条件与消息（C11）。
  - 在`_Alignas`中，包围对齐值（C11）。
  - 在属性中，包围属性参数（C23）。
  - 在`_BitInt(N)`中，包围位宽N（C23）。
  - 在可变参数宏的`__VA_OPT__`中，包围可选内容（C23）。
  - 在`#embed`和`__has_embed`中，包围参数（C23）。
- **示例**：
  ```c
  int a = (1+2)*3; // 分组
  printf("%d", a); // 函数调用
  size_t s = sizeof(int); // sizeof运算符
  int *p = (int*)malloc(10); // 强制类型转换
  int *arr = (int[]){1,2,3}; // 复合字面量（C99）
  void (*func_ptr)(int) = &my_func; // 函数指针
  #define MAX(a, b) ((a)>(b)?(a):(b)) // 宏参数
  #if defined(DEBUG) // defined运算符
  _Generic(x, int:0, double:1)( // 泛型选择（C11）
  _Static_assert(sizeof(int)==4, "int must be 4 bytes"); // 静态断言（C11）
  _Alignas(16) int aligned_arr[4]; // 对齐说明（C11）
  [[deprecated("Use new_func")]] void old_func(); // 属性（C23）
  _BitInt(128) big_num; // 位精确整数（C23）
  #define LOG(...) printf(__VA_ARGS__ __VA_OPT__(,)) // __VA_OPT__（C23）
  ```

### 6. 分号 `;`
- **用途**：
  - 结束语句（包括for循环的初始化语句）。
  - 结束声明（包括结构体成员声明列表）。
  - 在for循环中，分隔三个子句（第一个子句后和第二个子句后）。
- **示例**：
  ```c
  int a; // 声明结束
  for (int i=0; i<10; i++) { ... } // for循环的三个部分
  ```

### 7. 冒号 `:`
- **用途**：
  - 条件运算符的一部分（`?:`）。
  - 标签声明的一部分（如`case`标签、`goto`标签）。
  - 在位域声明中，引入位宽。
  - 在枚举定义中，引入底层类型（C23）。
  - 在泛型关联中，分隔类型和表达式（C11）。
- **示例**：
  ```c
  int max = (a>b)?a:b; // 条件运算符
  case 1: ... // case标签
  struct { unsigned int flag:1; } bitfield; // 位域
  enum Color : char { RED, GREEN, BLUE }; // 指定枚举底层类型（C23）
  _Generic(x, int:0, default:1); // 泛型关联（C11）
  ```

### 8. 省略号 `...`
- **用途**：
  - 在函数参数列表中，表示可变参数（如`printf`）。
  - 在宏定义中，表示可变参数宏（C99）。
- **示例**：
  ```c
  int printf(const char *format, ...); // 可变参数函数
  #define debug(...) fprintf(stderr, __VA_ARGS__) // 可变参数宏（C99）
  ```

### 9. 问号 `?`
- **用途**：
  - 条件运算符的一部分（与冒号组合）。
- **示例**：
  ```c
  int abs = (x<0)?-x:x;
  ```

### 10. 双冒号 `::`
- **用途**：
  - 在属性中，指定属性作用域（C23）。
  - 在预处理器的`#embed`和`__has_embed`中，表示范围（C23）。
- **示例**：
  ```c
  [[gnu::always_inline]] void func(); // 指定属性作用域（C23）
  ```

### 11. 点 `.`
- **用途**：
  - 成员访问运算符（用于结构体或联合体）。
  - 在初始化器中，为结构体/联合体成员指定初始化（C99）。
- **示例**：
  ```c
  struct Point p;
  p.x = 10; // 访问成员
  struct Point p2 = { .x=1, .y=2 }; // 指定初始化（C99）
  ```

### 12. 箭头 `->`
- **用途**：
  - 成员访问运算符（用于指向结构体或联合体的指针）。
- **示例**：
  ```c
  struct Point *ptr = &p;
  ptr->x = 20;
  ```

### 13. 波浪号 `~`
- **用途**：
  - 一元按位取反运算符。
- **示例**：
  ```c
  unsigned int flags = ~0; // 所有位设为1
  ```

### 14. 感叹号 `!`
- **用途**：
  - 逻辑非运算符。
- **示例**：
  ```c
  if (!valid) { ... }
  ```

### 15. 加号 `+`
- **用途**：
  - 一元正号运算符（通常不改变操作数）。
  - 二元加法运算符。
- **示例**：
  ```c
  int a = +5; // 一元
  int b = a + 3; // 二元
  ```

### 16. 减号 `-`
- **用途**：
  - 一元负号运算符。
  - 二元减法运算符。
- **示例**：
  ```c
  int a = -5; // 一元
  int b = a - 3; // 二元
  ```

### 17. 星号 `*`
- **用途**：
  - 间接引用运算符（解引用指针）。
  - 乘法运算符。
  - 在声明中，表示指针（指针声明符）。
  - 在函数参数中，表示变长数组（VLA）的占位符（C99）。
- **示例**：
  ```c
  int a = *ptr; // 解引用
  int c = a * b; // 乘法
  int *p; // 指针声明
  void func(int n, int arr[*]); // VLA占位符（C99）
  ```

### 18. 斜杠 `/`
- **用途**：
  - 除法运算符。
- **示例**：
  ```c
  int a = 10 / 2;
  ```

### 19. 百分号 `%`
- **用途**：
  - 取模（求余）运算符。
- **示例**：
  ```c
  int remainder = 10 % 3; // 1
  ```

### 20. 插入符 `^`
- **用途**：
  - 按位异或运算符。
- **示例**：
  ```c
  int result = a ^ b; // 异或
  ```

### 21. 与符号 `&`
- **用途**：
  - 取地址运算符。
  - 按位与运算符。
- **示例**：
  ```c
  int *p = &var; // 取地址
  int flags = FLAG1 & FLAG2; // 按位与
  ```

### 22. 竖线 `|`
- **用途**：
  - 按位或运算符。
- **示例**：
  ```c
  int flags = FLAG1 | FLAG2; // 按位或
  ```

### 23. 等号 `=`
- **用途**：
  - 简单赋值运算符。
  - 在初始化中，分隔变量和初始化式。
  - 在枚举定义中，为枚举常量指定值。
- **示例**：
  ```c
  int a = 10; // 初始化和赋值
  enum { MAX = 100 }; // 枚举常量赋值
  ```

### 24. 复合赋值运算符 `+=`, `-=`, `*=`, `/=`, `%=`, `^=`, `&=`, `|=`, `<<=`, `>>=`
- **用途**：
  - 复合赋值：先进行运算，再赋值。
- **示例**：
  ```c
  a += 5; // 等同于 a = a + 5
  ```

### 25. 比较运算符 `==`, `!=`, `<`, `>`, `<=`, `>=`
- **用途**：
  - 比较两个操作数。
  - 另外，`<`和`>`在`#include`、`__has_include`、`#embed`等中用于包围头文件名。
- **示例**：
  ```c
  if (a == b) { ... }
  #include <stdio.h> // < >用于头文件名
  ```

### 26. 逻辑运算符 `&&`, `||`
- **用途**：
  - 逻辑与和逻辑或。
- **示例**：
  ```c
  if (a && b) { ... }
  ```

### 27. 位移运算符 `<<`, `>>`
- **用途**：
  - 左移和右移。
- **示例**：
  ```c
  int shifted = value << 2; // 左移2位
  ```

### 28. 自增/自减 `++`, `--`
- **用途**：
  - 前缀或后缀的自增/自减。
- **示例**：
  ```c
  a++; // 后缀自增
  --b; // 前缀自减
  ```

### 29. 逗号 `,`
- **用途**：
  - 逗号运算符（按顺序求值，返回最后一个表达式的值）。
  - 在声明、初始化列表、函数参数列表、枚举列表、宏参数列表等中作为分隔符。
  - 在泛型选择中，分隔泛型关联（C11）。
  - 在属性列表中，分隔多个属性（C23）。
  - 在静态断言中，分隔条件与消息（C11）。
  - 在泛型选择中，分隔控制表达式和关联列表（C11）。
- **示例**：
  ```c
  for (int i=0, j=10; i<j; i++, j--) // 逗号运算符
  int arr[3] = {1,2,3}; // 初始化列表
  printf("%d %d", a, b); // 函数参数
  enum Color { RED, GREEN, BLUE }; // 枚举列表
  #define ADD(a, b) ((a)+(b)) // 宏参数
  _Generic(x, int:0, float:1, default:2); // 泛型关联（C11）
  [[noreturn, deprecated]] void exit(int); // 属性列表（C23）
  _Static_assert(sizeof(int)==4, "error"); // 静态断言（C11）
  _Generic(x, default:0)( // 泛型选择（C11）
  ```

### 总结

C语言中的标点符号是构建程序语法的基础。它们具有多种用途，从组织代码结构（如花括号`{}`定义块）、声明和定义（如分号`;`结束语句）、运算符（如`+`、`*`等）到预处理指令（如`#`）。理解每个标点符号的上下文含义对于编写正确的C程序至关重要。

值得注意的是，某些标点符号在不同的上下文中有不同的含义（例如`*`可以表示乘法、指针声明或解引用）。另外，C语言标准在不断演进，尤其是C23引入了一些新的用法（如属性中的双冒号`::`、`#embed`等）。

在实际编程中，正确使用标点符号可以避免语法错误，并确保程序逻辑正确。建议开发者熟悉这些标点符号的所有用途，并在编写代码时注意上下文。
*/

/**
* @brief             brief
* @return  int       Return Description
*
* @note              Revision History
*/
int punctuation_fn()
{

    printf("punctuation function begin...");

    return 0;
}