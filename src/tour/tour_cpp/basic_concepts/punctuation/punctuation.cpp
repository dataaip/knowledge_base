/**
* @file              punctuation.cpp
* @brief             brief
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2025.07.05
* @copyright         Copyright (c) 2025.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2025.07.05 <td>0.1             <td>brightl         <td>description
* </table>
*/

#include <iostream>

#define TOUR_CPP_BASIC_CONCEPTS

/*
标点C++ C++ 语言 基本概念 
这些是 C++ 中的标点符号。每个符号的含义在链接的页面中有详细说明。

预处理运算符

预处理运算符由预处理器识别。
#（包括%:)
引入 preprocessing 指令。
用于字符串化的预处理运算符。
##（包括%：%：)
用于标记粘贴的预处理运算符。

单字符运算符和标点符号

{和 （包括 和}<%%>)
在类定义中，分隔成员规范。
在枚举定义中，分隔枚举器列表。
分隔复合语句。compound 语句可以是
  函数定义
  一个 try 块
  Lambda 表达式（自 C++11 起）
初始化器的聚合初始化（C++11 之前）list-initialization（C++11 起）语法的一部分。
在命名空间定义中，分隔命名空间正文。
在语言链接规范中，分隔声明。
在 requires 表达式中，分隔要求。
在复合要求中，分隔表达式。
在导出声明中，分隔声明。（自 C++20 起）

[和 （包括]<:和:>)
下标运算符;部分运算符在运算符重载中。
声明或 type-id 中的数组声明符的一部分（例如，在新表达式中）。
部分新运算符重载 （分配函数） 中的运算符。
部分删除[]运算符 （operator in delete expression） 和运算符重载 （deallocation function）。
在 lambda 表达式中，分隔捕获。
在属性说明符中，分隔属性。（自 C++11 起）
在结构化绑定声明中，分隔标识符列表。（自 C++17 起）
在包索引中，分隔表示索引的转换后的常量表达式。（自 C++26 起）

(和)
在表达式中，指示分组。
函数调用运算符;部分运算符（）在运算符重载中。
在函数样式类型强制转换中，分隔 expression/initializers。
在 static_cast、const_cast、reinterpret_cast 或 dynamic_cast 中，分隔表达式。
分隔以下运算符的作数：
  typeid
  sizeof
  sizeof...
  alignof
  noexcept（自 C++11 起）
在 placement new 表达式中，分隔 placement 参数。
在新表达式中，可以选择分隔 type-id。
在新表达式中，分隔初始值设定项。
在 C 样式转换中，分隔 type-id。
在声明或 type-id 中，指示分组。
分隔 中的参数列表
  函数声明符（在声明或 Type-ID 中)
  Lambda 表达式（自 C++11 起）
  用户定义的扣减指南（自 C++17 起）
  a requires 表达式（自 C++20 起）
初始值设定项的直接初始化语法的一部分。
在 asm 声明中，分隔字符串 Literals。
在成员初始值设定项列表中，将初始值设定项分隔为基类或成员。
分隔 selection 语句或 iteration 语句的控制子句，包括：
  if （consteval if 除外）（自 C++23 起）
  switch
  while
  do-while
  for
  基于范围的（自 C++11 起）
在处理程序中，分隔参数声明。
在类似函数的宏定义中，分隔宏参数。
在类似函数的宏调用中，分隔宏参数或防止将逗号解释为参数分隔符。
是 ， __has_include（自 C++17 年起）、__has_cpp_attribute（自 C++20 年起）预处理运算符的一部分。defined
在 static_assert 声明中，分隔作数。
分隔以下说明符的作数：
  decltype
  noexcept
  alignas
  explicit（自 C++20 起）
在属性中，分隔属性参数。（自 C++11 起）
decltype（auto） 说明符的一部分。（自 C++14 起）
分隔折叠表达式。（自 C++17 起）
可变__VA_OPT__宏定义中替换的一部分。（自 C++20 起）

;
指示 的结束
A 声明
声明或成员声明
模块声明、导入声明、全局模块片段介绍人或私有模块片段介绍人
要求（自 C++20 起）
将 for 语句的 condition 和 statement 分开。

:
条件运算符的一部分。
标签声明的一部分。
在类定义的 base-clause 中，引入 base 类。
成员规范中访问说明符的一部分。
在 bit-field 成员声明中，引入 width.
在构造函数定义中，引入成员初始值设定项列表。
在基于范围的 for 语句中，将 item 声明和 range-initializer 分开。
在枚举声明的 enum-base 中，引入底层类型。（自 C++11 起）
在属性说明符中，将 attribute-namespace 和 attribute-list 分开。（自 C++17 起）
在 module partition 的 module declaration 或 import declaration 中，引入 module partition 名称。
私有模块 fragment introducer （模块 ：private;).（自 C++20 起）

?
条件运算符的一部分。

.
Member access 运算符。
在 aggregate initialization 中，引入一个 designator。
模块名称或模块分区名称的一部分。（自 C++20 起）

~（包括完成)
一元补码运算符（又名按位非运算符）;部分算子~在运算符重载中。
标识符表达式的一部分，用于命名析构函数或伪析构函数。

!（包括不)
逻辑 not 运算符;部分作员！在运算符重载中。
consteval if 语句的一部分。（自 C++23 起）

+
一元加号运算符;部分作员+在运算符重载中。
二进制加运算符;部分作员+在运算符重载中。

-
一元减号运算符;部分运算符-在运算符重载中。
二进制减号运算符;部分运算符-在运算符重载中。

*
间接运算符;部分作员*在运算符重载中。
乘法运算符;部分作员*在运算符重载中。
声明符或类型 ID 中的指针运算符或指向成员运算符的指针的一部分。
部分*这个在 Lambda 捕获列表中，按 Copy 捕获当前对象。（自 C++17 起）

/
除法运算符;部分运算符/在运算符重载中。

%
模运算符;部分运算符%在运算符重载中。

^（包括异或)
按位 xor 运算符;部分运算符^在运算符重载中。

&（包括bit和)
Address-of 运算符;部分运算符&在运算符重载中。
按位和运算符;部分运算符&在运算符重载中。
声明符或类型 ID 中的左值引用运算符。
在 lambda 捕获中，指示按引用捕获。
成员函数声明中的 ref 限定符。（自 C++11 起）

|（包括比特)
按位 or 运算符;部分运算符|在运算符重载中。

=
简单赋值运算符;部分运算符=在运算符重载中，这可能是一个特殊的成员函数（复制赋值运算符或移动赋值运算符（自 C++11 起））。
初始化器的复制初始化和聚合初始化（C++11 之前）copy-list-initialization（C++11 起）语法的一部分。
在函数声明中，引入 default 参数。
在模板参数列表中，引入默认模板参数。
在命名空间别名定义中，将别名和别名命名空间分开。
在枚举定义中，引入 enumerator 的值。
纯虚函数声明中 pure-specifier 的一部分。
lambda 捕获中的捕获默认值，用于指示按副本捕获。
默认定义的一部分 （=违约;） 或删除的定义 （=删除;） 的 API 定义。
在类型别名声明中，将别名和别名类型分开。（自 C++11 起）
在概念定义中，将概念名称和约束表达式分开。（自 C++20 起）

<
小于运算符;部分运算符<在运算符重载中。
在 static_cast、const_cast、reinterpret_cast 或 dynamic_cast 中，引入 type-id。
引入模板参数列表。
在 中引入模板参数列表
模板声明
部分特化
Lambda 表达式（自 C++20 起）
部分模板<>在模板特化声明中。
在
#include 指令
__has_include预处理表达式（自 C++17 起）
进口申报（自 C++20 起）

>
大于运算符;部分运算符>在运算符重载中。
static_cast、const_cast、reinterpret_cast 或 dynamic_cast 表示 type-id 的结尾。
指示模板参数列表的结尾。
在
模板声明
部分特化
Lambda 表达式（自 C++20 起）
部分模板<>在模板特化声明中。
在 中指示标头名称的结尾
#include 指令
__has_include预处理表达式（自 C++17 起）
进口申报（自 C++20 起）

,
逗号运算符;部分算子在运算符重载中。
中的列表分隔符
声明中的 declarator 列表
初始化中的初始化程序列表
放置 new 中的 placement 参数列表
函数调用表达式中的参数列表
枚举声明中的枚举器列表
类声明中的基类列表
构造函数定义中的成员初始值设定项列表
函数参数列表
模板参数列表
模板参数列表
Lambda 捕获列表
属性列表（自 C++11 起）
using 声明中的 declarator 列表
结构化绑定声明中的标识符列表（自 C++17 起）
多参数下标表达式中的参数列表（自 C++23 起）
类似函数的宏定义中的宏参数列表
类函数宏调用中的宏参数列表，除非在参数的括号之间找到
在 static_assert 声明中，分隔参数。（自 C++11 起）

多字符运算符和标点符号

...
在函数声明符或 lambda 表达式（C++11 起）或用户自定义推导指南（C++17 起）的参数列表中，表示可变参数函数。
在处理程序中，表示 catch-all 处理程序。
在宏定义中，表示可变参数宏。
指示 pack 声明和扩展。（自 C++11 起）
在 pack 索引表达式和说明符中。（自 C++26 起）

::
范围解析运算符
限定名称
指向成员声明的指针
new 或 delete 表达式，用于指示仅查找全局分配或释放函数
在属性中，指示属性范围。（自 C++11 起）
嵌套命名空间定义的一部分。（自 C++17 起）

.*
指向成员的指针访问运算符。

->
Member access 运算符;的一部分运算符>在运算符重载中。
在函数声明符或 lambda 表达式中，引入尾随返回类型。（自 C++11 起）
在用户定义的推导指南中，引入结果类型。（自 C++17 起）
在复合要求中，引入返回类型要求。（自 C++20 起）

->*
指向成员的指针访问运算符;的一部分运算符 >*在运算符重载中。

+=
复合赋值运算符;的一部分运算符 +=在运算符重载中。

-=
复合赋值运算符;的一部分运算符 =在运算符重载中。

*=
复合赋值运算符;的一部分运算符*=在运算符重载中。

/=
复合赋值运算符;的一部分运算符/=在运算符重载中。

%=
复合赋值运算符;的一部分作员%=在运算符重载中。

^=（包括xor_eq)
复合赋值运算符;的一部分运算符^=在运算符重载中。

&=（包括and_eq)
复合赋值运算符;的一部分运算符&=在运算符重载中。

|=（包括or_eq)
复合赋值运算符;的一部分运算符|=在运算符重载中。

==
相等运算符;的一部分运算符==在运算符重载中。

!=（包括not_eq)
不等式运算符;的一部分运算符！=在运算符重载中。

<=
小于或等于运算符;的一部分运算符<=在运算符重载中。

>=
大于或等于运算符;的一部分运算符>=在运算符重载中。

<=>
三方比较（飞船）运营商;部分运算符<=>在运算符重载中。（自 C++20 起）

&&（包括和)
逻辑 and 运算符;的一部分运算符&&在运算符重载中。
声明符或类型 ID 中的右值引用运算符。
成员函数声明中的 ref 限定符。（自 C++11 起）

||（包括或)
逻辑 or 运算符;的一部分运算符 ||在运算符重载中。

<<
位移位运算符;的一部分运算符<<在运算符重载 （按位运算符或流插入运算符） 中。

>>
位移位运算符;的一部分运算符>>在运算符重载 （按位运算符或流提取运算符） 中。

<<=
复合赋值运算符;的一部分运算符<<=在运算符重载中。

>>=
复合赋值运算符;的一部分运算符>>=在运算符重载中。

++
Increment 运算符;部分运算符++在运算符重载中。

--
递减运算符;部分运算符 --在运算符重载中。

引用
C++23 标准 （ISO/IEC 14882：2024）：5.12 运算符和标点符号 [lex.operators]
C++20 标准 （ISO/IEC 14882：2020）：5.12 运算符和标点符号 [lex.operators]
C++17 标准 （ISO/IEC 14882：2017）：5.12 运算符和标点符号 [lex.operators]
C++14 标准 （ISO/IEC 14882：2014）：2.13 运算符和标点符号 [lex.operators]
C++11 标准 （ISO/IEC 14882：2011）：2.13 运算符和标点符号 [lex.operators]
C++03 标准 （ISO/IEC 14882：2003）：2.12 运算符和标点符号 [lex.operators]
C++98 标准 （ISO/IEC 14882：1998）：2.12 运算符和标点符号 [lex.operators]

另请参阅
替代表示	某些运算符的替代拼写
*/

/*
我们面对的是一个关于C++标点符号的详细描述，需要深入、完整地解释每个概念，并举例说明，最后总结。C++的标点符号在代码中扮演着关键角色，包括语法结构、运算符、预处理器指令等。我们将按照描述中的分类进行解释，并给出示例。

 首先，我们将标点符号分为几大类：预处理运算符、单字符运算符和标点符号、多字符运算符和标点符号。然后，对每个符号进行详细说明，并给出示例。

 1. 预处理运算符
    - `#`：用于引入预处理指令，如`#include`，`#define`等。也用于字符串化操作符（在宏定义中将参数转换为字符串）。
    - `##`：用于标记粘贴（Token Pasting），在宏定义中连接两个标记。

 示例：
   ```cpp
   // 字符串化
   #define STRINGIFY(x) #x
   const char* str = STRINGIFY(test); // 变成 "test"

   // 标记粘贴
   #define CONCAT(a, b) a ## b
   int xy = 10;
   int result = CONCAT(x, y); // 相当于 xy，值为10
   ```

 2. 单字符运算符和标点符号
    - `{ }`：用于类定义、枚举定义、复合语句（代码块）、初始化列表等。
    - `[ ]`：数组下标、数组声明、lambda表达式捕获列表、属性等。
    - `( )`：函数调用、表达式分组、函数声明参数列表、类型转换等。
    - `;`：语句结束、声明结束、for循环中条件与迭代部分的分隔。
    - `:`：条件运算符的一部分、标签声明、基类列表、访问说明符、位域宽度指定等。
    - `.`：成员访问。
    - `~`：按位取反运算符，也用于析构函数名。
    - `!`：逻辑非运算符。
    - `+`：一元正号或二元加法运算符。
    - `-`：一元负号或二元减法运算符。
    - `*`：解引用、乘法、指针声明。
    - `/`：除法运算符。
    - `%`：取模运算符。
    - `^`：按位异或运算符。
    - `&`：取地址、按位与、引用声明（左值引用）。
    - `|`：按位或运算符。
    - `=`：赋值运算符。
    - `<`：小于运算符，也用于模板参数列表的开始和#include指令。
    - `>`：大于运算符，也用于模板参数列表的结束和#include指令。
    - `,`：逗号运算符，用于分隔列表中的项目（如参数、初始化列表等）。

 3. 多字符运算符和标点符号
    - `...`：可变参数（用于函数参数列表、宏定义中的可变参数、catch-all处理程序、参数包（C++11起））。
    - `::`：作用域解析运算符。
    - `.*`：指向成员的指针访问（通过对象）。
    - `->`：通过指针访问成员，也用于尾随返回类型（C++11起）。
    - `->*`：指向成员的指针访问（通过指针）。
    - 复合赋值运算符：`+=`, `-=`, `*=`, `/=`, `%=`, `^=`, `&=`, `|=`, `<<=`, `>>=`
    - 比较运算符：`==`, `!=`, `<=`, `>=`, `<=>`（C++20的三方比较运算符）
    - 逻辑运算符：`&&`, `||`
    - 位移运算符：`<<`, `>>`
    - 自增自减：`++`, `--`

 接下来，我们针对一些复杂或特殊的用法举例说明：

 1. 作用域解析运算符 `::`
    ```cpp
    int count = 0;  // 全局变量

    class MyClass {
    public:
        static int count; // 类静态成员
    };

    int MyClass::count = 0; // 类外定义，使用::

    int main() {
        int count = 0; // 局部变量
        ::count = 1;   // 使用全局count
        MyClass::count = 2; // 使用类的静态成员
    }
    ```

 2. 尾随返回类型（使用`->`）
    ```cpp
    // 普通函数
    auto add(int a, int b) -> int {
        return a + b;
    }

    // 在lambda表达式中
    auto lambda = [](int x) -> double { return x * 1.5; };
    ```

 3. 可变参数模板（使用`...`）
    ```cpp
    template<typename... Args>
    void print(Args... args) {
        // 使用折叠表达式（C++17）
        (std::cout << ... << args) << std::endl;
    }

    int main() {
        print(1, 2.5, "hello");
    }
    ```

 4. 属性（使用`[ ]`）
    ```cpp
    [[nodiscard]] int compute() { 
        return 42; 
    }

    int main() {
        compute(); // 警告：忽略nodiscard值
    }
    ```

 5. 三方比较运算符 `<=>`（C++20）
    ```cpp
    #include <compare>
    struct Point {
        int x, y;
        auto operator<=>(const Point&) const = default;
    };

    int main() {
        Point a{1,2}, b{1,3};
        if (a < b) { / * ... * / } // 使用自动生成的比较
    }
    ```

 6. 模块（C++20）中的符号使用
    ```cpp
    // 模块声明
    module;
    #include <iostream>
    export module mymodule;

    export void hello() {
        std::cout << "Hello, Module!" << std::endl;
    }

    // 导入模块
    import mymodule;
    int main() {
        hello();
    }
    ```

 7. 结构化绑定（C++17）使用`[ ]`
    ```cpp
    std::tuple<int, double, std::string> getTuple() {
        return {1, 2.5, "hello"};
    }

    int main() {
        auto [a, b, c] = getTuple(); // 分解元组
    }
    ```

 8. 折叠表达式（C++17）中的逗号和运算符
    ```cpp
    template<typename... Args>
    auto sum(Args... args) {
        return (args + ...); // 折叠求和
    }
    ```

 9. 成员指针运算符（`.*`和`->*`）
    ```cpp
    class MyClass {
    public:
        int value;
    };

    int main() {
        int MyClass::*ptr = &MyClass::value; // 指向成员的指针

        MyClass obj;
        obj.*ptr = 10; // 通过对象使用成员指针

        MyClass* pObj = &obj;
        pObj->*ptr = 20; // 通过指针使用成员指针
    }
    ```

 10. 概念（C++20）中的`=`和`requires`
     ```cpp
     template <typename T>
     concept Integral = std::is_integral_v<T>;

     template <Integral T>
     T add(T a, T b) {
         return a + b;
     }
     ```

 总结：

 C++的标点符号是构建程序的基础元素，它们具有多种用途，从基本的运算符到复杂的模板和模块系统。随着C++标准的演进，一些标点符号的用法也在扩展（如`<=>`、模块导入导出等）。理解每个标点符号的上下文含义对于编写正确的C++代码至关重要。

 关键点：
   - 预处理运算符（`#`和`##`）主要在宏定义中使用，但现代C++推荐使用其他特性（如constexpr、模板）来替代宏。
   - 单字符运算符在表达式和声明中无处不在，注意同一符号在不同上下文中的含义（如`&`可以是取地址、按位与、引用声明）。
   - 多字符运算符通常由单字符运算符组合而成，但具有独立的语义（如`<<`可以是位移，也可以是流插入）。
   - C++11以来引入的新特性（如尾随返回类型、lambda捕获列表、属性、结构化绑定、折叠表达式等）赋予了标点符号新的角色。
   - C++20的重大更新（如模块、概念、三方比较）进一步扩展了标点符号的使用。

 在实际编程中，应遵循现代C++的最佳实践，合理使用标点符号，并注意其在不同上下文中的含义，以避免混淆和错误。
*/

/**
* @brief             brief
* @return  int       Return Description
*
* @note              Revision History
*/
auto punctuation_fn() -> int
{

    std::cout << "punctuation function begin..." << std::endl;

    return 0;
}