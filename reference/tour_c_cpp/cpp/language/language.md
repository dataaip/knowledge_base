# C++ 语言概念（知识增强版）

- [C++ 语言概念（知识增强版）](#c-语言概念知识增强版)
  - [基础概念](#基础概念)
  - [关键字](#关键字)
  - [预处理器](#预处理器)
  - [表达式](#表达式)
  - [声明](#声明)
  - [初始化](#初始化)
  - [函数](#函数)
  - [语句](#语句)
  - [类](#类)
  - [模板](#模板)
  - [异常](#异常)
  - [杂项和习语](#杂项和习语)

---

## 基础概念

**注释**：C++ 支持两种注释方式，单行注释 `//`，从`//`开始到行尾的所有内容都会被忽略。多行注释 `/* */`，可以跨越多行。C++17 引入了嵌套注释的支持，允许在多行注释中嵌套其他多行注释。

**ASCII 编码**：ASCII（ American Standard Code for Information Interchange ）是一种基于拉丁字母的字符编码标准，使用 7 位二进制数表示 128 个字符（ 0-127 ）。C++11 引入了对 Unicode 字面量的支持，允许在字符串和字符字面量中使用 Unicode 字符。

**标点符号**：标点符号是 C++ 中除运算符外的语法符号，用于分隔语句、表达式等。常见的标点符号包括，方括号 `[]` 用于数组索引、花括号 `{}` 用于复合语句或初始化列表、分号 `;` 用于结束语句、作用域解析运算符 `::` 用于访问命名空间或类中的成员。

**名称与标识符**：标识符是程序员定义的名称，用于命名变量、函数、类型等。标识符的命名规则只能由字母（ A-Z, a-z ）、数字（ 0-9 ）和下划线（ _ ）组成、不能以数字开头、区分大小写，例如 `variable` 和 `Variable` 是不同的标识符。

**类型**：C++ 的类型系统包括基础类型、复合类型和类类型，基础类型如 ( `int`/`char`/`float`/`double` )等、复合类型如 指针/引用等、类类型如 ( `class`/`struct`/`union` ) 等。

**基本类型**：C++的基本类型包括 `void` 表示空类型、`bool` 布尔类型、整型如 (  `char`/`short`/`int`/`long`/`long long` ) 等、浮点型如 ( `float`/`double`/`long doubl` ) 等。

**对象**: 对象是内存中存储数据的区域，具有类型、值、生存期和存储期等属性。对象的生存期从构造开始，到析构结束。

**作用域**: 作用域决定了标识符在程序中的可见性范围，块作用域 在复合语句（ 如`{}` ）内部定义的标识符，仅在该块内可见、类作用域 在类中定义的标识符，在整个类内可见、命名空间作用域 在命名空间中定义的标识符，在整个命名空间内可见、全局作用域 在文件顶层定义的标识符，在整个程序中可见。

**对象生存期**：对象的生存期从构造开始，到析构结束。通过`malloc`等函数创建的对象没有构造函数和析构函数，因此没有生存期的概念。

**存储持续期与链接性**：存储持续期决定了对象在程序运行期间的存在时间，自动存储期 局部变量默认具有自动存储期，存储在栈上，函数调用结束后自动销毁、静态存储期 全局变量和静态变量具有静态存储期，存储在全局数据区，程序启动时创建，程序结束时销毁、线程存储期 使用 `thread_local` 关键字声明的变量，每个线程都有独立的副本、动态存储期 通过 `new` 等操作符动态分配的内存，存储在堆上，需要手动释放。链接性决定了标识符在不同编译单元中的可见性，内部链接 仅在当前编译单元中可见、外部链接 在所有编译单元中可见、无链接 仅在当前作用域中可见。

**定义与 ODR**：单一定义规则（ ODR ）要求每个标识符只能有一个定义，且在所有编译单元中必须一致。

**名称查找**：C++ 中的名称查找包括普通查找和参数依赖查找（ ADL ），普通查找 按照作用域逐级查找、参数依赖查找（ ADL ）根据函数参数的类型查找相关命名空间中的函数。

**限定名称查找**：限定名称查找用于访问类或命名空间中的成员 `Class::member` 。

**非限定名称查找**：非限定名称查找从当前作用域开始，逐级向外层作用域查找。

**as-if 规则**：如同规则（ as-if rule ）允许编译器对代码进行优化，只要优化后的代码与原始代码在可观测行为上一致。

**未定义行为 UB**：未定义行为是指标准未规定其行为的结果，可能导致程序崩溃、产生错误结果或表现出不可预测的行为。例如空指针解引用、数组越界访问、除以零。

**内存模型**：C++11 引入了内存模型，用于支持多线程编程。内存模型定义了多线程环境下的内存访问语义，确保程序的正确性。

**多线程执行与数据竞争**：当多个线程同时访问共享数据且至少有一个线程进行写操作时，必须使用同步机制（如互斥锁、原子操作）来避免数据竞争。

**字符集与编码**：C++ 支持多种字符集和编码方式，基本源字符集 包括字母、数字、标点符号等，执行字符集 用于程序执行时的字符表示，支持 UTF-8、UTF-16、UTF-32 等编码。

**翻译编译阶段**：C++ 源代码的翻译过程分为多个阶段，字符映射 将源文件中的字符映射到基本源字符集、行拼接 处理反斜杠续行符（`\`）、预处理 处理宏定义条件编译等预处理指令、转义序列处理 处理字符串和字符常量中的转义序列（如`\n`/`\t`）、拼接字符串 将相邻的字符串字面量拼接在一起、语法分析 进行词法和语法分析生成抽象语法树、模板处理 处理模板实例化、链接 将多个目标文件链接成可执行文件。

**main 函数**：`main` 函数是程序的入口点，其标准形式为 `int main(int argc, char* argv[])` ，`argc` 命令行参数的数量，`argv` 指向命令行参数的指针数组，返回值为 0 表示程序正常退出。

**模块**：C++20 引入了模块（ module ），用于替代传统的头文件机制，提高编译效率和代码组织性。

**合约**：C++20 曾引入合约（ contract ）机制，用于在代码中声明前置条件、后置条件和断言，但后来被移除。

---

## 关键字

**标准关键字**：C++ 的标准关键字共有 97 个，涵盖了基本的控制结构、数据类型、存储类说明符等。这些关键字是 C++ 语言的核心组成部分，不能用作标识符。

**标识符特殊含义**：某些标识符在特定上下文中具有特殊含义，`final` 用于类或虚函数表示不能被继承或重写、`override` 用于虚函数表示重写基类的虚函数、`import` C++20 引入用于导入模块、`module` C++20 引入用于定义模块。

**预处理器关键字**：预处理器关键字用于预处理指令，`define` 定义宏、`include` 包含文件、`ifdef` 条件编译、`pragma` 编译器特定指令。

**替代符号**：C++ 支持替代符号，用于替代某些运算符，`and` 替代`&&`、`or` 替代`||`、`not` 替代`!`、`bitand` 替代`&`。

**预留标识符**：预留标识符是指以双下划线开头或包含双下划线的标识符，这些标识符保留给实现使用，程序员不应使用。

**C++11/14/17/20/23/26 各版本中引入新关键字**：C++ 各版本引入了新的关键字 C++11 `auto`（新义）、`constexpr`、`decltype`、`nullptr`。C++20 `concept`、`requires`、`char8_t`。

---

## 预处理器

**条件编译指令**：条件编译指令用于根据条件选择性地编译代码，`#if` 如果条件为真则编译后续代码、`#ifdef` 如果宏已定义则编译后续代码、`#elif` 否则如果条件为真，则编译后续代码、`#else` 否则编译后续代码、`#endif` 结束条件编译块。C++23 新增了 `#elifdef` 和 `#elifndef` 分别用于检查宏是否定义或未定义。

**宏定义指令**：宏定义指令用于定义宏，`#define` 定义宏、`#undef` 取消宏定义。宏还可以进行字符串化和标记粘贴操作 `#` 将宏参数转换为字符串、`##` 将两个标记粘贴在一起。

**文件包含指令**：文件包含指令用于包含其他文件的内容，`#include <>` 包含系统头文件、`#include ""` 包含用户头文件。

**编译器特定指令**：`#pragma` 用于向编译器传递特定指令，如优化控制、警告抑制等。常见的用法包括 `#pragma once` 确保头文件只被包含一次。

**行号与文件名**：`#line`指令用于修改当前的行号和文件名，常用于调试信息。

**错误控制指令**：`#error` 强制编译器报错并显示指定消息、C++23 新增 `#warning` 显示警告消息但不中断编译。

**其他控制指令**：`#` 空指令，用于占位、`_Pragma` 操作符形式的 `#pragma`  可以在宏中使用。

---

## 表达式

**值类别**：C++ 中的表达式可以分为以下几类，左值（ lvalue ）具有标识且可寻址的表达式可以出现在赋值操作的左侧、右值（ rvalue ）可以移动的表达式通常表示临时对象、亡值（ xvalue ）即将消亡的右值通常表示将要被移动的对象、纯右值（ prvalue ）临时值不能出现在赋值操作的左侧。

**求值顺序**：C++11 废除了序列点规则，改为部分有序的求值顺序，`&&`、`||`、`?:`、`,`等运算符的求值顺序是从左到右。其他运算符的求值顺序是未定义的。

**常量表达式**：常量表达式是在编译时可以求值的表达式，使用 `constexpr` 关键字声明 `constexpr int x = 42;`。

**基本表达式**：基本表达式包括，标识符 变量或函数的名称、字面量如 `42`/`3.14`/`"str"` 等、`this`  指向当前对象的指针、`lambda` 表达式 匿名函数、`requires` 约束 用于约束模板参数、折叠表达式用于处理参数包、包索引 C++26 引入用于访问参数包中的元素、括号分组表达式 用于改变运算符优先级。

**字面量**：C++ 支持多种类型的字面量，布尔字面量 `true`和`false`、整型字面量如`42`、浮点字面量如`3.14`、字符字面量如`'A'`、字符串字面量如`"str"`、空指针字面量如 `nullptr`、用户定义字面量 如`123_km`。

**运算符类别**：C++ 的运算符按功能分类如下，赋值运算符 `=`, `+=`, `-=`, `*=`, `/=`, `%=`等、算术运算符 `+`, `-`, `*`, `/`, `%`等、自增/自减运算符 `++`, `--`、逻辑运算符 `&&`, `||`, `!`、比较运算符 `==`, `!=`, `>`, `<`, `>=`, `<=`、位运算符 `&`, `|`, `^`, `~`, `<<`, `>>`、成员访问运算符 `.`, `->`、函数调用运算符 `()`、逗号运算符 `,`、三元运算符 `?:`、内存管理运算符 `new`, `delete`、类型查询运算符 `alignof`, `typeid`, `sizeof`、异常运算符 `noexcept`、折叠运算符 `... op ...`、默认比较运算符 `<=>`、运算符替代 如`and`, `or`, `not`等、运算符重载 允许用户自定义运算符的行为。

**运算符优先级**：C++ 的运算符优先级共 19 级，从高到低依次为 `::`（作用域解析）。`()`（函数调用）、`[]`（数组索引）、`.`（成员访问）、`->`（指针成员访问）。`++`、`--`（后缀自增/自减）。`typeid`、`sizeof`、`alignof`、`noexcept`。`~`（按位取反）、`!`（逻辑非）、`+`（正号）、`-`（负号）、`++`、`--`（前缀自增/自减）、`*`（解引用）、`&`（取地址）、`new`、`delete`。`.*`、`->*`（成员指针）。`*`（乘法）、`/`（除法）、`%`（取模）。`+`（加法）、`-`（减法）。`<<`（左移）、`>>`（右移）。`<`、`>`、`<=`、`>=`（比较）。`==`、`!=`（相等）。`&`（按位与）。`^`（按位异或）。`|`（按位或）。`&&`（逻辑与）。`||`（逻辑或）。`?:`（三元）。`=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`、`|=`（赋值）。`,`（逗号）。

**转换类别**：C++ 支持多种类型转换，隐式转换 如整型提升、算术转换等。显式转换 如`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`。用户定义转换 通过转换函数实现。

**关键概念**：完整表达式 不是其他表达式的子表达式的表达式、可能求值 包含运行时求值的表达式、丢弃值 无副作用的表达式、表达式等价 具有相同行为的表达式。

---

## 声明

**声明基础**：C++ 的声明语法为 `[属性] [说明符] 声明符 [初始化器]` ，属性 如`[[nodiscard]]`。说明符 如`const`、`static`等。声明符 如变量名、函数名等。初始化器 如`= 42`。

**说明符**：说明符用于指定声明的属性，声明规范序列 如`typedef`、`inline`等。函数说明符 如`inline`、`virtual`、`explicit`。`friend` 用于声明友元函数或友元类。`consteval` C++20 引入用于声明立即函数。类型说明符 如`int`、`class`、`struct`、`union`、`enum`等。`constexpr` 用于声明常量表达式。`constinit` C++20 引入用于声明常量初始化。`decltype` 用于获取表达式的类型。`auto` 用于自动类型推导。`alignas` 用于指定对齐方式。`const` 用于声明常量。`volatile` 用于声明易变变量。存储类说明符 如`register`、`static`、`extern`、`thread_local`。类型名限定符 如`const`、`volatile`等。精炼类型说明符 如`signed`、`unsigned`等。打包索引指定符 用于访问参数包中的元素。属性 如`[[nodiscard]]`。

**声明符**：声明符用于指定声明的类型和结构，声明器 如变量名、函数名等。数据对象 如变量、函数等。标识符 如变量名、函数名等。限定名 如 `Class::member`。参数包 用于处理可变参数。指针 如`*p`。成员指针 如`.*`。引用 如`&r`、`&&r`。数组 如`arr[10]`。函数 如`func()`。分组声明 如`(声明符)`。

**块声明**：块声明用于在代码块中声明变量或类型，简单声明 如`int x;`。结构化绑定 如`auto [a, b] = t;`。类型别名声明 如`using Int = int;`。`namespace`别名 如`namespace fs = std::filesystem;`。`using`声明 如`using std::cout;`。`using`指令 如`using namespace std;`。`static_assert` 用于编译时断言。`asm`内联汇编 用于嵌入汇编代码。不透明枚举声明 如`enum class Color;`。

**其他声明**：其他声明包括，命名空间定义 如`namespace MyNamespace { ... }`。函数声明 如`int func();`。类模板 如`template<typename T> class MyClass {};`。函数模板 如`template<typename T> void func(T t);`。显式实例化 如`template class MyClass<int>;`。显式模板特化 如`template<> class MyClass<int> {};`。链接规范 如`extern "C" { ... }`。属性 如`[[nodiscard]]`。空声明 如`;`。

**声明与定义**：声明 引入名称但不分配存储。定义 分配存储或提供函数体。

**声明符组合**：声明符可以组合使用，指针+引用 如`int*& r`。数组+函数 如`int(*f)(int)[10]`。

---

## 初始化

**初始化器**：C++ 支持多种初始化语法，等号初始化如`int x = 42;`、花括号初始化 如`int x{42};`、圆括号初始化 如`int x(42);`。

**默认初始化**：默认初始化是指在没有显式初始化器时的初始化行为，内置类型 值未定义、类类型 调用默认构造函数。

**值初始化**：值初始化使用花括号语法 `T obj{};` 内置类型 初始化为零值、类类型 调用默认构造函数。

**拷贝初始化**：拷贝初始化使用等号语法 `T obj = other;` 调用拷贝构造函数。

**直接初始化**：直接初始化使用圆括号语法 `T obj(arg);` 调用匹配的构造函数。

**聚合初始化**：聚合初始化用于数组或简单类 `int arr[] = {1, 2, 3}; struct Point { int x, y; }; Point p = {1, 2};`

**列表初始化**：列表初始化使用花括号语法，优先匹配`std::initializer_list std::vector<int> v = {1, 2, 3};`

**引用初始化**：引用初始化用于绑定引用，左值引用 绑定到左值、右值引用 绑定到右值。

**静态初始化**：静态初始化在编译期进行，零初始化 将对象初始化为零值、常量初始化 将对象初始化为常量值。

**动态非局部初始化**：涉及跨编译单元的初始化顺序问题，有序初始化 按照定义顺序初始化、无序初始化 初始化顺序未定义。

**拷贝消除**：拷贝消除是编译器优化，用于省略拷贝或移动操作 `T func() { return T{}; } T obj = func();  // 可能省略拷贝`。

---

## 函数

**函数声明**：函数声明包括返回类型、函数名、参数列表和限定符 `int func(int param);`。

**函数参数**：函数参数包括，形参声明 如`int param`。默认参数 如`int func(int param = 42)`。可变参数 如`void func(int n, ...)`。`va_list` 用于访问可变参数。

**函数定义**：函数定义包括函数声明和函数体 `int func(int param) { return param; }`。

**函数调用**：函数调用涉及：实参传递 将实参传递给形参。ADL 查找 根据参数类型查找相关函数。`operator()`函数调用运算符 用于函数对象。函数对象 如 lambda 表达式、函数指针等。

**重载**：函数重载是指在相同作用域中定义同名但参数列表不同的函数 `void func(int x); void func(double x);` 重载解析根据实参类型选择最匹配的函数。

**函数协定说明符**：函数协定说明符用于指定函数的异常行为，`noexcept` 表示函数不会抛出异常。`throws` 已弃用用于指定可能抛出的异常类型。

**内联说明符**：`inline`关键字建议编译器将函数调用替换为函数体，以减少函数调用开销。

**Lambda 表达式**：`Lambda` 表达式是匿名函数，语法为 `[captures](parameters) -> return_type { body }`。例如 `auto lambda = [](int x) { return x * 2; };`。

**协程**：C++20 引入了协程，支持异步编程，`co_await` 用于等待异步操作完成。`co_yield` 用于生成器函数返回值并暂停执行。

**替代函数**：`if constexpr` 用于编译时分支，替代传统的函数重载 `template<typename T> void func(T t) { if constexpr (std::is_integral_v<T>) { /*处理整型*/ } else { /*处理其他类型*/ } }`

---

## 语句

**标签语句**：标签语句用于标记代码位置，`label:` 用于`goto`语句的目标。`case:` 用于`switch`语句的分支。

**表达式语句**：表达式语句是由表达式后跟分号组成的语句，`x++;`。

**复合语句**：复合语句是由一对花括号包围的语句块，用于创建新的作用域 `{ int x = 10; /*x 在此作用域内可见*/ }`。

**选择语句**：选择语句用于根据条件执行不同的代码路径，`if/else` 根据条件执行代码。`switch/case/default`  根据表达式的值执行不同的代码块。

**迭代语句**：迭代语句用于重复执行代码，`for` 循环执行代码，通常用于已知循环次数的情况。`range-for` C++11 引入用于遍历容器。`while` 当条件为真时循环执行代码。`do-while` 至少执行一次循环体，然后根据条件决定是否继续。

**跳转语句**：跳转语句用于改变程序的执行流程，`break` 跳出循环或 `switch` 语句。`continue` 跳过当前循环的剩余部分，进入下一次循环。`goto` 跳转到指定标签。`return` 从函数返回。

**断言语句**：`assert` 用于运行时检查条件 `assert(x > 0);`。

**声明语句**：声明语句用于在代码块中声明变量 `int x = 42;`。

**try 块**：用于异常处理 `try { /* 可能抛出异常的代码 */ } catch (...) { /* 异常处理代码 */ }`。

**事务内存**：C++20 引入了事务内存的实验特性，`synchronized` 用于创建原子块。

---

## 类

**基础概述**：C++支持多种类类型，`class` 默认访问权限为`private`。`struct` 默认访问权限为`public`。`union` 共享内存的类，同一时间只能存储一个成员。注入类名 ( 类内可用简名 )。

**类的属性**：包括 平凡可复制 可以使用`memcpy`复制。平凡 具有默认构造函数。标准布局 与 C 兼容的布局。隐式生命周期类 具有隐式生命周期管理。POD 平凡且标准布局的类。

**成员**：类的成员包括，数据成员 如`int x;`。静态成员 如`static int count;`。嵌套类 在类中定义的类。成员模板 在类中定义的模板。位字段 如`int b : 3;`。`using`声明 用于引入基类成员。`this`指针 指向当前对象的指针。成员函数 如`void func();`。访问说明符 如`public`、`protected`、`private`。默认成员初始值设定项 如`int x = 42;`。`mutable` 允许在`const`成员函数中修改成员。`friend` 用于声明友元函数或友元类。`explicit` 用于防止隐式转换。

**特殊成员函数**：特殊成员函数包括，构造函数 用于初始化对象。成员初始值设定项列表 用于初始化成员。默认构造函数 无参数的构造函数。拷贝构造函数 用于拷贝对象。移动构造函数 用于移动对象。拷贝赋值运算符 用于拷贝赋值。移动赋值运算符 用于移动赋值。转换构造函数 用于类型转换。析构函数 用于销毁对象。

**继承**：继承用于创建派生类，基类和派生类 派生类继承基类的成员。抽象类 包含纯虚函数的类。空基类优化 优化空基类的存储。虚继承 用于解决多重继承中的菱形问题。虚函数 可以被派生类重写的函数。纯虚函数 `=0`表示纯虚函数。`override` 表示重写基类的虚函数。`final` 表示不能被继承或重写。

---

## 模板

**基础模板**：模板用于定义泛型代码，类模板 如 `template<typename T> class MyClass {};`。函数模板 如`template<typename T> void func(T t);`。类成员模板 在类中定义的模板。变量模板 C++14 引入，如 `template<typename T> constexpr T pi = T(3.1415926535897932385);`。

**参数**：模板参数包括，类型参数 如`typename T`。非类型参数 如`int N`。模板参数推导 根据实参推导模板参数。类模板参数推导 C++17 引入，自动推导类模板参数。

**特化**：模板特化用于为特定类型提供特殊实现，显式特化 为特定类型提供完全不同的实现。部分特化 仅适用于类模板为部分参数提供特殊实现。

**参数包**：参数包用于处理可变参数，包 如`Ts...`。可变模板参数 如`template<typename... Ts>`。`sizeof...` 获取参数包的大小。折叠表达式 C++17 引入，用于处理参数包。包索引 用于访问参数包中的元素。

**依赖名称**：依赖名称是指依赖于模板参数的名称，名称查找 根据模板参数查找名称。`typename` 用于消除歧义。SFINAE 替换失败非错误，用于模板元编程。

**约束和概念**：C++20 引入了约束和概念，`concept` 用于定义约束。`requires`子句 用于指定约束条件。

---

## 异常

**异常对象**：异常对象通过`throw`语句创建并传递 `throw std::runtime_error("error");`。

**异常使用**：异常处理通过`try`和`catch`块实现 `try { /* 可能抛出异常的代码 */ } catch (const std::exception& e) { /* 异常处理代码 */ }`。

**异常安全**：异常安全保证包括，基本保证 保证对象处于有效状态。强保证 保证操作要么成功要么回滚到原始状态。无异常保证 保证操作不会抛出异常。

**异常规范**：异常规范用于指定函数可能抛出的异常，`noexcept` 表示函数不会抛出异常。动态异常规范 已弃用用于指定可能抛出的异常类型。

**constexpr 异常**：C++20 允许在 `constexpr` 函数中使用 `throw`， `constexpr int func(int x) { if (x < 0) { throw std::runtime_error("negative value"); } return x; }`。

---

## 杂项和习语

**好奇反复模板模式 ( CRTP )**：CRTP（Curiously Recurring Template Pattern）是一种模板设计模式，派生类作为基类的模板参数。

```cpp
template<typename Derived>
class Base {
public:
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
};

class Derived : public Base<Derived> {
public:
    void implementation() {
        // 实现
    }
};
```

**实现指针 ( PIMPL )**：PIMPL（Pointer to Implementation）是一种设计模式，通过前置声明实现类来隐藏实现细节。

```cpp
// Header file
class MyClass {
public:
    MyClass();
    ~MyClass();
    void func();
private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
};

// Implementation file
class MyClass::Impl {
public:
    void func() {
        // 实现
    }
};

MyClass::MyClass() : pImpl(std::make_unique<Impl>()) {}
MyClass::~MyClass() = default;
void MyClass::func() { pImpl->func(); }
```

**资源获取即初始化 ( RAII )**：RAII（Resource Acquisition Is Initialization）是一种资源管理技术，通过构造函数获取资源，通过析构函数释放资源。

```cpp
class File {
public:
    File(const char* filename) : file(fopen(filename, "r")) {}
    ~File() { if (file) fclose(file); }
private:
    FILE* file;
};
```

**三法则/五法则/零法则**：三法则 如果需要自定义析构函数、拷贝构造函数或拷贝赋值运算符，则需要自定义所有三个。五法则 C++11 引入移动语义后，扩展为五个特殊成员函数。零法则 如果不需要自定义特殊成员函数，则不要自定义。

**零开销原则**：零开销原则是指不使用则不付出成本，使用时高效。C++ 的设计目标之一就是实现零开销抽象。

**C++的历史**：C++ 的发展历程，C with Classes C++ 的前身。C++98 第一个标准化版本。C++11 引入了大量新特性，如自动类型推导、lambda 表达式等。C++14 对 C++11 的改进。C++17 引入了结构化绑定、`if constexpr`等。C++20 引入了概念、协程、模块等。C++23 继续引入新特性。

**扩展 std 命名空间**：用户不应直接向`std`命名空间添加内容，但可以特化`std`中的模板。

**缩写**：RAII 资源获取即初始化。TMP 模板元编程。SFINAE 替换失败非错误。NTTP 非类型模板参数。

---
