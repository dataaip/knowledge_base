# C++ 参考手册

## 参考手册

| 标题         | 内容                                                         |
| ------------ | ------------------------------------------------------------ |
| 语言标准     | C++98, C++03, C++11, C++14, C++17, C++20, C++23, C++26       |
| 编译器支持   | C++11, C++14, C++17, C++20, C++23, C++26                     |
| 语言概念     | 基础概念，关键字，预处理器，表达式，声明，初始化，函数，语句，类，模板，异常 ，杂项和习语 |
| 标准库头文件 | 语言支持库，概念库，诊断库，内存管理库，元编程库，通用实用程序库，容器库，迭代器库，范围库，算法库，字符串库，文本处理库，数字库，日期和时间库，输入/输出库，并发支持库，执行控制库，C 兼容标头 |
| 命名要求     | 基本要求，类型属性，库级要求，容器，迭代，流 I/O 函数，格式化程序，随机数生成，并发，范围，多维视图定制，其他 |
| 功能测试     | 属性，语言功能，库功能，编译器功能转储                       |
| 技术规格     | 实验性-功能标准库扩展（库基础 TS），TR/TS 规格，非 TS 提案   |
| 有用资源     | 标准 C++ 基础 isocpp.org，C++ 常见问题解答，C++ 标准文档和草稿，C++ 语言和库引用，C++ ABI，模式、习语、提示和技巧，相关标准，非 ANSI/ISO C++ 库列表 |

---

### 语言标准

| 语言标准 | 内容                                                         |
| -------- | ------------------------------------------------------------ |
| C++98    | 第一个正式标准                                               |
| C++03    | 对 C++98 的小幅修订                                          |
| C++11    | C++11 是现代 C++（Modern C++）时代的起点                     |
| C++14    | 对 C++11 的小幅修订                                          |
| C++17    | C++17 专注于提高语言和库的实用性                             |
| C++20    | C++20 是一个革命性的版本，旨在提高 C++ 的表达能力、性能和易用性 |
| C++23    | 开发中-C++23 是一个持续发展的标准，专注于完善和增强现有特性  |
| C++26    | 开发中-C++26 是下一代 C++ 标准                               |

#### 知识增强：语言标准详解

C++98 是 C++ 语言的第一个正式标准，由 ISO 于 1998 年发布。它奠定了现代 C++ 的基础，引入了许多重要的特性，如 STL（标准模板库）、模板、异常处理、命名空间等。C++98 的发布标志着 C++ 成为一门成熟的编程语言。

C++03 是对 C++98 的一次小幅修订，主要修复了一些小错误和不一致之处，未引入新的语言特性。它的目标是确保 C++98 的稳定性和一致性。

C++11 是 C++ 发展史上的一个重要里程碑，被称为“现代 C++”的起点。它引入了许多新特性，极大地增强了语言的功能性和表达能力，包括：
- 自动类型推导（`auto`）
- 范围 for 循环
- Lambda 表达式
- 右值引用和移动语义
- 智能指针（`std::unique_ptr`、`std::shared_ptr`）
- 并发支持（`std::thread`、`std::mutex`）
- 统一初始化语法（`{}`）
- `nullptr` 替代 `NULL`
- `constexpr` 和 `noexcept` 关键字

C++14 是对 C++11 的一次小幅修订，主要增强了已有特性，如：
- 泛型 Lambda 表达式
- 返回类型推导（`auto`）
- 二进制字面量
- 数字分隔符（`'`）

C++17 专注于提高语言和库的实用性，引入了许多实用的新特性，如：
- 结构化绑定（`auto [x, y] = make_pair(1, 2);`）
- `if constexpr`（编译时条件判断）
- `std::optional`、`std::variant`、`std::any`
- 文件系统库（`<filesystem>`）
- 并行算法（`std::execution`）

C++20 是一个革命性的版本，引入了许多重大新特性，旨在提高 C++ 的表达能力、性能和易用性，包括：
- 概念（Concepts）
- 范围（Ranges）
- 协程（Coroutines）
- 模块（Modules）
- 三向比较运算符（`<=>`）
- `std::format`（格式化库）

C++23 是一个持续发展的标准，专注于完善和增强现有特性。它引入了一些新特性，如：
- `std::print`（更简单的打印函数）
- `std::expected`（错误处理）
- `std::mdspan`（多维视图）
- 改进的 `std::format`

C++26 是下一代 C++ 标准，仍在开发中。预计将进一步增强语言的功能性和表达能力，如：
- 合约（Contracts）
- 更强大的模块支持
- 改进的协程支持

---

### 编译器支持

| 编译器支持 | 内容                        |
| ---------- | --------------------------- |
| C++11      | GCC，Clang，MSVC，Intel C++ |
| C++14      | GCC，Clang，MSVC，Intel C++ |
| C++17      | GCC，Clang，MSVC，Intel C++ |
| C++20      | GCC，Clang，MSVC，Intel C++ |
| C++23      | GCC，Clang，MSVC，Intel C++ |
| C++26      | GCC，Clang，MSVC，Intel C++ |

#### 知识增强：编译器支持详解

GCC 是一个开源的编译器套件，支持多种编程语言，包括 C 和 C++。它对 C++ 标准的支持非常全面，尤其是对 C++11、C++14、C++17 和 C++20 的支持较为成熟。GCC 还提供了许多扩展功能，如内联汇编、属性声明等。

Clang 是 LLVM 项目的一部分，以其快速编译速度和优秀的错误提示而闻名。它对 C++ 标准的支持也非常出色，尤其是在 C++11、C++14、C++17 和 C++20 方面表现优异。Clang 的设计目标是替代 GCC，成为下一代主流编译器。

MSVC 是微软开发的 C/C++ 编译器，主要用于 Windows 平台。虽然它对 C++11 的支持相对较晚，但在 C++14、C++17 和 C++20 方面已经逐步完善。MSVC 提供了丰富的调试工具和集成开发环境（IDE），适合 Windows 开发者使用。

Intel C++ 是英特尔开发的 C/C++ 编译器，专注于高性能计算。它对 C++ 标准的支持也非常全面，尤其是在优化方面表现出色。Intel C++ 编译器可以生成高度优化的代码，特别适合科学计算和工程应用。

---

### 语言概念

| 语言概念   | 内容                                                         |
| ---------- | ------------------------------------------------------------ |
| 基础概念   | 注释，ASCII编码，标点符号，名称与标识符，类型，基本类型，对象，作用域，对象生存期，存储持续期与链接性，定义与ODR，名称查找，限定名称查找，非限定名称查找，as-if 规则，未定义行为，内存模型，多线程执行与数据竞争(C++11)，字符集与编码，翻译编译阶段，main函数，模块(C++20)，合约 （C++26） |
| 关键字     | 标准关键字，标识符特殊含义，预处理器关键字，替代符号，预留标识符， C++11/14/17/20 各版本中引入新关键字 |
| 预处理器   | 条件编译指令，宏定义指令，文件包含指令，错误控制指令，其他控制指令 |
| 表达式     | 通用概念常规，字面量，运算符，转换机制，内存管理类，其他特性，主表达式，完整表达式，丢弃值表达式，潜在评估表达式，表达式等价性 |
| 声明       | 声明语法，说明符，声明符，简单声明，特殊声明，块声明，模板声明，属性声明，空声明，其他声明 |
| 初始化     | 初始值设定项，非局部变量，默认初始化，值初始化，直接初始化，拷贝初始化，列表初始化，聚合初始化，引用初始化，复制省略，静态初始化，动态非本地初始化，类成员初始化 |
| 函数       | 函数声明，函数参数列表，函数定义，函数协定说明符 （C++26），默认参数，可变参数参数，内联说明符，Lambda 表达式 （C++11），协程 （C++20），替换函数，函数调用，参数相关查找 （ADL），函数调用运算符，函数对象重载，过载解决，操作员超负荷，重载集的地址 |
| 语句       | 标签语句，表达式语句，复合语句，选择语句，迭代语句，跳转语句，断言语句，声明语句，try块，事务内存 |
| 类         | 一般概述，类/结构类型，联合类型，注入的类名，类的属性，类属性说明符 （C++26），成员，数据成员，静态成员，this 指针，嵌套类，成员模板，位字段，使用声明，成员函数，成员访问说明符，构造函数和成员初始值设定项列表，默认成员初始值设定项 （C++11），好友说明符，显式说明符，转换构造函数，特殊成员函数，默认构造函数，复制构造函数，移动构造函数 （C++11），复制赋值运算符，移动赋值运算符 （C++11），析构函数，继承，基类和派生类，空碱优化 （EBO），虚拟成员函数，纯虚函数和抽象类，覆盖说明符 （C++11），最终说明符 （C++11） |
| 模板       | 模板参数，类模板，函数模板，类成员模板，变量模板 （C++14），模板参数推演，类模板参数推导 （C++17），显式（完整）模板专用化，部分模板专用化，依赖名称，包 （C++11），sizeof...（C++11），折叠表达式 （C++17），包索引（C++26），SFINAE，约束和概念 （C++20），requires需要表达式 （C++20） |
| 异常       | 用法，异常对象，try块，抛出异常，处理异常，异常规范，noexcept规范（C++11），动态规范（C++17前），noexcept运算符（C++11）、constexpr异常（C++26） |
| 杂项和习语 | C++ 的历史，扩展命名空间 `std`，首字母缩略词，`ASM` 声明，自立式与宿主式实现，好奇重复的模板模式 （CRTP），指向实现的指针 （PIMPL），资源获取即初始化 （RAII），三/五/零法则，零开销原则 |

#### 知识增强：语言概念详解

**基础概念**

- **注释**：C++ 支持两种注释形式，分别是 `/* ... */`（多行注释）和 `//`（单行注释）。注释不会被编译器处理，仅用于提高代码的可读性。
- **ASCII编码**：C++ 默认使用 ASCII 编码，每个字符对应一个唯一的数值。ASCII 编码范围为 0 到 127，涵盖了英文字母、数字和常用符号。
- **标点符号**：C++ 中的标点符号包括分号（`;`）、逗号（`,`）、括号（`()`）、花括号（`{}`）等，用于分隔语句、表达式和代码块。
- **名称与标识符**：标识符是程序员定义的名称，用于标识变量、函数、类型等。标识符必须以字母或下划线开头，后面可以跟字母、数字或下划线。
- **类型**：C++ 支持多种数据类型，包括基本类型（如 `int`、`float`）、派生类型（如指针、数组、结构体）和用户自定义类型（如 `typedef`）。
- **基本类型**：基本类型包括整型（如 `int`、`long`）、浮点型（如 `float`、`double`）、字符型（如 `char`）、布尔型（如 `bool`）等。
- **对象**：对象是内存中的一个区域，用于存储数据。对象可以是变量、函数、类实例等。
- **作用域**：作用域决定了标识符在程序中的可见范围。C++ 中有四种作用域：文件作用域、函数作用域、块作用域和函数原型作用域。
- **对象生存期**：对象生存期决定了对象在程序运行期间的存在时间。C++ 中有三种生存期：静态生存期、自动生存期和动态生存期。
- **存储持续期与链接性**：存储持续期决定了对象的生命周期，链接性决定了对象在不同文件中的可见性。C++ 中有四种存储持续期：静态、自动、线程和动态。
- **定义与ODR**：ODR（One Definition Rule）规定了每个实体在程序中只能有一个定义。违反 ODR 会导致未定义行为。
- **名称查找**：名称查找是指编译器如何找到标识符的定义。C++ 中有两种名称查找：限定名称查找和非限定名称查找。
- **限定名称查找**：限定名称查找是指通过作用域解析运算符（`::`）来查找标识符。
- **非限定名称查找**：非限定名称查找是指不使用作用域解析运算符来查找标识符。
- **as-if 规则**：as-if 规则允许编译器对程序进行优化，只要优化后的程序在行为上与原始程序相同即可。
- **未定义行为**：未定义行为是指程序的行为无法预测，可能引发错误或异常。常见的未定义行为包括访问空指针、除以零等。
- **内存模型**：内存模型定义了程序中各个线程如何访问共享内存。C++11 引入了多线程内存模型，确保多线程程序的正确性。
- **多线程执行与数据竞争**：多线程执行是指程序中多个线程同时运行。数据竞争是指多个线程同时访问同一内存位置且至少有一个线程进行写操作，可能导致不可预测的结果。
- **字符集与编码**：C++ 支持多种字符集和编码，如 ASCII、UTF-8、UTF-16 等。
- **翻译编译阶段**：C++ 的编译过程分为多个阶段，包括预处理、词法分析、语法分析、语义分析、优化和代码生成。
- **main函数**：`main()` 函数是 C++ 程序的入口点，程序从这里开始执行。它可以接受命令行参数，并返回一个整数值表示程序的退出状态。
- **模块（C++20）**：模块是 C++20 引入的新特性，用于替代传统的头文件机制，提供更好的封装性和编译速度。
- **合约（C++26）**：合约是 C++26 预计引入的新特性，用于在代码中声明前置条件、后置条件和不变量，帮助提高代码的健壮性。

**关键字**

- **标准关键字**：C++ 的标准关键字包括 `int`、`char`、`void`、`if`、`else`、`for`、`while`、`return` 等，它们具有特殊的含义，不能用作标识符。
- **标识符特殊含义**：某些标识符在特定上下文中具有特殊含义，如 `override`、`final` 等。
- **预处理器关键字**：预处理器关键字包括 `#define`、`#include`、`#if` 等，用于预处理阶段的操作。
- **替代符号**：替代符号是指可以用其他符号替代的关键字，如 `and` 替代 `&&`、`or` 替代 `||` 等。
- **预留标识符**：预留标识符是指保留给未来标准使用的标识符，如 `_` 开头的标识符。
- **C++11/14/17/20 各版本中引入新关键字**：每个版本都引入了新的关键字，如 `auto`（C++11）、`constexpr`（C++11）、`decltype`（C++11）、`nullptr`（C++11）、`override`（C++11）、`final`（C++11）、`thread_local`（C++11）、`alignas`（C++11）、`alignof`（C++11）、`noexcept`（C++11）、`static_assert`（C++11）、`char16_t`（C++11）、`char32_t`（C++11）、`decltype(auto)`（C++14）、`generic`（C++14）、`co_await`（C++20）、`co_return`（C++20）、`co_yield`（C++20）等。

**预处理器**

- **条件编译指令**：条件编译指令包括 `#if`、`#ifdef`、`#ifndef`、`#elif`、`#else`、`#endif`，用于根据条件选择性地编译代码。
- **宏定义指令**：宏定义指令包括 `#define` 和 `#undef`，用于定义和取消宏。宏可以是简单的替换，也可以是带参数的函数式宏。
- **文件包含指令**：文件包含指令 `#include` 用于将其他文件的内容插入到当前文件中，常用于包含头文件。
- **错误控制指令**：错误控制指令 `#error` 用于在编译时产生错误信息，常用于检测配置错误。
- **其他控制指令**：其他控制指令包括 `#pragma`、`#line` 等，用于控制编译器的行为。

**表达式**

- **通用概念常规**：表达式是由操作数和运算符组成的，用于计算值或执行操作。
- **字面量**：字面量是直接写在代码中的常量，如 `123`、`'A'`、`"Hello"`。
- **运算符**：运算符用于对操作数进行操作，包括算术运算符（如 `+`、`-`）、关系运算符（如 `==`、`!=`）、逻辑运算符（如 `&&`、`||`）等。
- **转换机制**：转换是指将一种类型的值转换为另一种类型，包括隐式转换和显式转换。
- **内存管理类**：内存管理类包括 `new`、`delete`、`malloc`、`free` 等，用于动态分配和释放内存。
- **其他特性**：其他特性包括 `sizeof`、`typeid` 等，用于获取对象的大小和类型信息。
- **主表达式**：主表达式是最基本的表达式，包括标识符、常量、字符串字面量等。
- **完整表达式**：完整表达式是指在某个点上完全求值的表达式。
- **丢弃值表达式**：丢弃值表达式是指其结果被丢弃的表达式。
- **潜在评估表达式**：潜在评估表达式是指可能被求值的表达式。
- **表达式等价性**：表达式等价性是指两个表达式在所有情况下都产生相同的结果。

**声明**

- **声明语法**：声明语法用于声明变量、函数、类型等。声明语法包括类型说明符、存储类说明符、类型限定符等。
- **说明符**：说明符用于指定变量或函数的属性，如 `const`、`volatile`、`static`、`extern` 等。
- **声明符**：声明符用于指定变量或函数的名称和类型，包括指针、数组、函数等。
- **简单声明**：简单声明是指声明一个或多个变量或函数。
- **特殊声明**：特殊声明包括 `typedef`、`using`、`friend` 等，用于定义类型别名、友元函数等。
- **块声明**：块声明是指在代码块中声明的变量或函数。
- **模板声明**：模板声明用于定义模板类或模板函数。
- **属性声明**：属性声明用于指定变量或函数的属性，如 `[[noreturn]]`、`[[deprecated]]` 等。
- **空声明**：空声明是指不声明任何内容的声明。
- **其他声明**：其他声明包括 `namespace`、`using` 等，用于定义命名空间和使用声明。

**初始化**

- **初始值设定项**：初始值设定项用于初始化变量，可以是常量、表达式或函数调用。
- **非局部变量**：非局部变量是指在函数外部声明的变量。
- **默认初始化**：默认初始化是指在声明变量时不指定初始值，由编译器自动初始化为默认值。
- **值初始化**：值初始化是指将变量初始化为特定值。
- **直接初始化**：直接初始化是指在声明变量时直接指定初始值。
- **拷贝初始化**：拷贝初始化是指通过拷贝另一个对象来初始化变量。
- **列表初始化**：列表初始化是指使用花括号 `{}` 来初始化变量。
- **聚合初始化**：聚合初始化是指对聚合类型（如数组、结构体）进行初始化。
- **引用初始化**：引用初始化是指对引用进行初始化。
- **复制省略**：复制省略是指编译器优化掉不必要的拷贝操作。
- **静态初始化**：静态初始化是指在程序启动时进行的初始化。
- **动态非本地初始化**：动态非本地初始化是指在程序运行时进行的初始化。
- **类成员初始化**：类成员初始化是指在类中初始化成员变量。

**函数**

- **函数声明**：函数声明用于告诉编译器函数的名称、返回类型和参数列表。
- **函数参数列表**：函数参数列表用于指定函数的参数类型和名称。
- **函数定义**：函数定义用于实现函数的具体功能。
- **函数协定说明符（C++26）**：函数协定说明符用于声明函数的前置条件、后置条件和不变量。
- **默认参数**：默认参数是指在函数声明中为参数指定默认值。
- **可变参数参数**：可变参数参数是指函数可以接受不定数量的参数。
- **内联说明符**：内联说明符用于指示函数应该被内联展开。
- **Lambda 表达式（C++11）**：Lambda 表达式用于定义匿名函数。
- **协程（C++20）**：协程用于实现异步编程。
- **替换函数**：替换函数是指可以被其他函数替换的函数。
- **函数调用**：函数调用是指调用函数并传递参数。
- **参数相关查找（ADL）**：参数相关查找是指根据参数类型来查找函数。
- **函数调用运算符**：函数调用运算符是指 `operator()`，用于定义函数对象。
- **函数对象重载**：函数对象重载是指重载函数调用运算符。
- **过载解决**：过载解决是指编译器如何选择合适的重载函数。
- **操作员超负荷**：操作员超负荷是指重载运算符。
- **重载集的地址**：重载集的地址是指获取重载函数的地址。

**语句**

- **标签语句**：标签语句用于标记代码中的某个位置，常用于 `goto` 语句。
- **表达式语句**：表达式语句是由一个表达式组成的语句，通常用于赋值或调用函数。
- **复合语句**：复合语句是由多个语句组成的代码块，用花括号 `{}` 包围。
- **选择语句**：选择语句包括 `if` 和 `switch`，用于根据条件选择执行不同的代码路径。
- **迭代语句**：迭代语句包括 `for`、`while` 和 `do-while`，用于重复执行代码块。
- **跳转语句**：跳转语句包括 `goto`、`break`、`continue` 和 `return`，用于改变程序的执行流程。
- **断言语句**：断言语句用于在调试时检查条件是否成立。
- **声明语句**：声明语句用于声明变量或函数。
- **try块**：try块用于捕获和处理异常。
- **事务内存**：事务内存用于实现事务性操作。

**类**

- **一般概述**：类是 C++ 中用于封装数据和函数的基本单位。
- **类/结构类型**：类和结构体是 C++ 中用于定义用户自定义类型的方式。
- **联合类型**：联合体用于定义多个成员共享同一内存区域的类型。
- **注入的类名**：注入的类名是指类名在类内部的作用域中可见。
- **类的属性**：类的属性包括成员变量、成员函数、访问说明符等。
- **类属性说明符（C++26）**：类属性说明符用于指定类的属性。
- **成员**：成员是指类中的变量和函数。
- **数据成员**：数据成员是指类中的变量。
- **静态成员**：静态成员是指属于类而不是对象的成员。
- **this 指针**：`this` 指针是指向当前对象的指针。
- **嵌套类**：嵌套类是指在类内部定义的类。
- **成员模板**：成员模板是指类中的模板函数或模板类。
- **位字段**：位字段是指在类中定义的占用特定位数的成员。
- **使用声明**：使用声明用于引入其他作用域中的名称。
- **成员函数**：成员函数是指类中的函数。
- **成员访问说明符**：成员访问说明符用于控制成员的可见性，包括 `public`、`private`、`protected`。
- **构造函数和成员初始值设定项列表**：构造函数用于初始化对象，成员初始值设定项列表用于初始化成员变量。
- **默认成员初始值设定项（C++11）**：默认成员初始值设定项用于为成员变量指定默认值。
- **好友说明符**：好友说明符用于授予其他类或函数访问私有成员的权限。
- **显式说明符**：显式说明符用于防止隐式转换。
- **转换构造函数**：转换构造函数用于将一种类型转换为另一种类型。
- **特殊成员函数**：特殊成员函数包括默认构造函数、复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符、析构函数。
- **默认构造函数**：默认构造函数是指没有参数的构造函数。
- **复制构造函数**：复制构造函数用于通过拷贝另一个对象来初始化对象。
- **移动构造函数（C++11）**：移动构造函数用于通过移动另一个对象来初始化对象。
- **复制赋值运算符**：复制赋值运算符用于通过拷贝另一个对象来赋值。
- **移动赋值运算符（C++11）**：移动赋值运算符用于通过移动另一个对象来赋值。
- **析构函数**：析构函数用于在对象销毁时执行清理操作。
- **继承**：继承是指一个类可以从另一个类派生，继承其成员。
- **基类和派生类**：基类是指被继承的类，派生类是指继承基类的类。
- **空碱优化（EBO）**：空碱优化是指编译器优化掉空基类的大小。
- **虚拟成员函数**：虚拟成员函数是指可以被派生类重写的成员函数。
- **纯虚函数和抽象类**：纯虚函数是指没有实现的虚拟函数，抽象类是指包含纯虚函数的类。
- **覆盖说明符（C++11）**：覆盖说明符用于指示成员函数覆盖基类中的虚拟函数。
- **最终说明符（C++11）**：最终说明符用于指示类或成员函数不能被继承或重写。

**模板**

- **模板参数**：模板参数是指模板中使用的参数，可以是类型参数或非类型参数。
- **类模板**：类模板是指可以生成多个类的模板。
- **函数模板**：函数模板是指可以生成多个函数的模板。
- **类成员模板**：类成员模板是指类中的模板函数或模板类。
- **变量模板（C++14）**：变量模板是指可以生成多个变量的模板。
- **模板参数推演**：模板参数推演是指编译器自动推导模板参数的类型。
- **类模板参数推导（C++17）**：类模板参数推导是指编译器自动推导类模板参数的类型。
- **显式（完整）模板专用化**：显式模板专用化是指为特定类型显式定义模板的实现。
- **部分模板专用化**：部分模板专用化是指为特定类型的子集定义模板的实现。
- **依赖名称**：依赖名称是指依赖于模板参数的名称。
- **包（C++11）**：包是指可以接受不定数量参数的模板参数。
- **sizeof...（C++11）**：`sizeof...` 用于获取包中参数的数量。
- **折叠表达式（C++17）**：折叠表达式用于对包中的参数进行操作。
- **包索引（C++26）**：包索引用于访问包中的特定参数。
- **SFINAE**：SFINAE（Substitution Failure Is Not An Error）是指模板参数替换失败时不报错。
- **约束和概念（C++20）**：约束和概念用于限制模板参数的类型。
- **requires需要表达式（C++20）**：`requires` 表达式用于指定模板参数必须满足的条件。

**异常**

- **用法**：异常用于处理程序运行时的错误。
- **异常对象**：异常对象是指抛出的异常。
- **try块**：try块用于捕获和处理异常。
- **抛出异常**：抛出异常是指使用 `throw` 关键字抛出异常。
- **处理异常**：处理异常是指使用 `catch` 块捕获和处理异常。
- **异常规范**：异常规范用于指定函数可能抛出的异常类型。
- **noexcept规范（C++11）**：`noexcept` 规范用于指示函数不会抛出异常。
- **动态规范（C++17前）**：动态规范用于指定函数可能抛出的异常类型。
- **noexcept运算符（C++11）**：`noexcept` 运算符用于检查表达式是否可能抛出异常。
- **constexpr异常（C++26）**：`constexpr` 异常用于在编译时处理异常。

**杂项和习语**

- **C++ 的历史**：C++ 起源于 1980 年代，由 Bjarne Stroustrup 在贝尔实验室开发，最初称为“C with Classes”。
- **扩展命名空间 `std`**：扩展命名空间 `std` 是指在 `std` 命名空间中添加新的内容。
- **首字母缩略词**：首字母缩略词是指由单词首字母组成的缩写，如 `RAII`、`CRTP` 等。
- **`ASM` 声明**：`ASM` 声明用于在 C++ 代码中嵌入汇编代码。
- **自立式与宿主式实现**：自立式实现是指不依赖操作系统的实现，宿主式实现是指依赖操作系统的实现。
- **好奇重复的模板模式（CRTP）**：CRTP 是一种设计模式，用于实现静态多态。
- **指向实现的指针（PIMPL）**：PIMPL 是一种设计模式，用于隐藏实现细节。
- **资源获取即初始化（RAII）**：RAII 是一种资源管理技术，确保资源在对象销毁时被释放。
- **三/五/零法则**：三/五/零法则是指如果需要定义析构函数、复制构造函数或复制赋值运算符，则可能需要定义所有三个；如果需要定义移动构造函数或移动赋值运算符，则可能需要定义所有五个；如果不需要定义任何特殊成员函数，则可以使用默认实现。
- **零开销原则**：零开销原则是指 C++ 的设计目标是不为不需要的功能付出代价。

---

### 标准库头文件

| 标准库         | 内容                                                         |
| -------------- | ------------------------------------------------------------ |
| 语言支持库     | 实现属性（C++ 20），类型支持，程序实用程序，动态内存管理，错误处理，可变参数函数，元编程（C++11），常量求值上下文（C++20），初始化列表（C++11），源代码信息捕获，三向比较（C++20），协程支持（C++20），合约支持（C++26） |
| 概念库         | 标准库概念，隐式表达式变体，输出相等，核心语言概念，对象生命周期概念，比较概念，对象概念，可调用概念 |
| 诊断库         | 异常处理，异常类别，例外类别，错误编号，系统错误，断言，堆栈跟踪，调试支持 |
| 内存管理库     | 分配器，未初始化的内存算法，受约束的未初始化内存算法，内存资源，显式生命周期管理，未初始化的存储，垃圾回收器支持， 复合类设计的类型，低级内存管理，智能指针，杂项，C 库 |
| 元编程库       | 类型特征类别，类型属性，支持的操作，属性查询，类型关系，类型修改，类型转换，类型特征常量，元函数，逻辑运算，成员关系 ，编译期整数序列，编译期有理数运算 |
| 通用实用程序库 | 交换操作，类型操作，整数比较函数，关系运算符，构造标签，对和元组，和类型和类型擦除包装器，位集，位操作，函数对象，哈希支持，常见词汇类型 |
| 容器库         | 节点句柄（C++17），序列容器，关联容器，无序关联容器，容器适配器，视图，迭代器失效，线程安全，函数表 |
| 迭代器库       | 迭代器概念，迭代器基元，迭代器自定义点，算法概念和实用程序，流迭代器，迭代器适配器，迭代器操作，范围访问 |
| 范围库         | 范围访问，范围基元，范围转换，悬空迭代器处理，范围概念，视图，范围工厂，范围适配器，范围生成器，范围适配器对象，范围适配器闭合对象，辅助项目 |
| 算法库         | 约束算法和范围算法，执行策略，非修改序列操作，修改序列操作，排序和相关操作，数值操作，未初始化内存操作，C 库 |
| 字符串库       | 字符，库组件，字符串类，字符串视图类，相关库                 |
| 文本处理库     | 本地化库，正则表达式库，格式化库，以空字符结尾的序列工具，基本数值转换，文本编码标识 |
| 数字库         | 常用数学函数，数学特殊函数， 数学常数，基本线性代数算法，数据并行类型，浮点环境，数值数组，复数运算，伪随机数生成，位操作，通用数字运算，因数运算，插值运算，饱和算术，检查整数算术 |
| 日期和时间库   | chrono库，C风格日期时间库，时间点，持续时间，时钟，一天中的时间，日历，Chrono I/O，时区，字面量 |
| 输入/输出库    | I/O操作器，打印函数，C风格I/O，缓冲区，基于流的I/O，抽象类，文件I/O，字符串I/O，数组I/O，同步输出，常用类型定义，预定义标准流对象，错误分类接口 |
| 并发支持库     | 线程管理，协作取消，缓存大小访问，互斥锁，条件变量，信号量，门闩和屏障，期程，安全回收，危险指示，原子类型，内存排序，原子操作的自由函数，原子标志的自由函数 |
| 执行控制库     | 执行概念，实用组件，核心操作，发送者算法                     |
| C 兼容标头     | C风格头文件，C++风格头文件                                   |

#### 知识增强：标准库头文件详解

**语言支持库**

- **实现属性（C++20）**：实现属性用于指定编译器的实现细节。
- **类型支持**：类型支持包括 `typeid`、`sizeof` 等，用于获取类型信息。
- **程序实用程序**：程序实用程序包括 `exit`、`abort` 等，用于控制程序的执行。
- **动态内存管理**：动态内存管理包括 `new`、`delete`、`malloc`、`free` 等，用于动态分配和释放内存。
- **错误处理**：错误处理包括 `try`、`catch`、`throw` 等，用于处理异常。
- **可变参数函数**：可变参数函数用于处理不定数量的参数。
- **元编程（C++11）**：元编程用于在编译时进行计算。
- **常量求值上下文（C++20）**：常量求值上下文用于在编译时求值常量表达式。
- **初始化列表（C++11）**：初始化列表用于初始化容器。
- **源代码信息捕获**：源代码信息捕获用于获取源代码的位置信息。
- **三向比较（C++20）**：三向比较用于比较两个对象。
- **协程支持（C++20）**：协程支持用于实现异步编程。
- **合约支持（C++26）**：合约支持用于声明前置条件、后置条件和不变量。

**概念库**

- **标准库概念**：标准库概念用于限制模板参数的类型。
- **隐式表达式变体**：隐式表达式变体用于定义隐式转换。
- **输出相等**：输出相等用于定义输出相等的概念。
- **核心语言概念**：核心语言概念用于定义语言的基本概念。
- **对象生命周期概念**：对象生命周期概念用于定义对象的生命周期。
- **比较概念**：比较概念用于定义比较操作。
- **对象概念**：对象概念用于定义对象的基本属性。
- **可调用概念**：可调用概念用于定义可调用对象。

**诊断库**

- **异常处理**：异常处理用于捕获和处理异常。
- **异常类别**：异常类别用于分类异常。
- **例外类别**：例外类别用于分类例外。
- **错误编号**：错误编号用于标识错误。
- **系统错误**：系统错误用于处理系统级别的错误。
- **断言**：断言用于在调试时检查条件是否成立。
- **堆栈跟踪**：堆栈跟踪用于获取程序的调用堆栈。
- **调试支持**：调试支持用于提供调试工具。

**内存管理库**

- **分配器**：分配器用于管理内存的分配和释放。
- **未初始化的内存算法**：未初始化的内存算法用于操作未初始化的内存。
- **受约束的未初始化内存算法**：受约束的未初始化内存算法用于操作受约束的未初始化内存。
- **内存资源**：内存资源用于管理内存资源。
- **显式生命周期管理**：显式生命周期管理用于显式管理对象的生命周期。
- **未初始化的存储**：未初始化的存储用于存储未初始化的对象。
- **垃圾回收器支持**：垃圾回收器支持用于支持垃圾回收。
- **复合类设计的类型**：复合类设计的类型用于设计复合类。
- **低级内存管理**：低级内存管理用于管理低级内存。
- **智能指针**：智能指针用于自动管理内存。
- **杂项**：杂项包括其他内存管理相关的功能。
- **C 库**：C 库包括 C 语言的内存管理函数。

**元编程库**

- **类型特征类别**：类型特征类别用于分类类型特征。
- **类型属性**：类型属性用于获取类型的属性。
- **支持的操作**：支持的操作用于支持类型操作。
- **属性查询**：属性查询用于查询类型的属性。
- **类型关系**：类型关系用于定义类型之间的关系。
- **类型修改**：类型修改用于修改类型。
- **类型转换**：类型转换用于转换类型。
- **类型特征常量**：类型特征常量用于定义类型特征的常量。
- **元函数**：元函数用于在编译时进行计算。
- **逻辑运算**：逻辑运算用于进行逻辑运算。
- **成员关系**：成员关系用于定义成员关系。
- **编译期整数序列**：编译期整数序列用于生成编译期整数序列。
- **编译期有理数运算**：编译期有理数运算用于进行编译期有理数运算。

**通用实用程序库**

- **交换操作**：交换操作用于交换两个对象的值。
- **类型操作**：类型操作用于操作类型。
- **整数比较函数**：整数比较函数用于比较整数。
- **关系运算符**：关系运算符用于定义关系运算。
- **构造标签**：构造标签用于标记构造函数。
- **对和元组**：对和元组用于存储多个值。
- **和类型和类型擦除包装器**：和类型和类型擦除包装器用于实现和类型和类型擦除。
- **位集**：位集用于存储位。
- **位操作**：位操作用于操作位。
- **函数对象**：函数对象用于定义函数对象。
- **哈希支持**：哈希支持用于支持哈希操作。
- **常见词汇类型**：常见词汇类型用于定义常见的词汇类型。

**容器库**

- **节点句柄（C++17）**：节点句柄用于管理容器中的节点。
- **序列容器**：序列容器用于存储序列数据，如 `vector`、`list`、`deque`。
- **关联容器**：关联容器用于存储关联数据，如 `set`、`map`。
- **无序关联容器**：无序关联容器用于存储无序关联数据，如 `unordered_set`、`unordered_map`。
- **容器适配器**：容器适配器用于适配容器，如 `stack`、`queue`。
- **视图**：视图用于提供容器的视图。
- **迭代器失效**：迭代器失效用于处理迭代器失效的情况。
- **线程安全**：线程安全用于确保容器的线程安全性。
- **函数表**：函数表用于存储函数。

**迭代器库**

- **迭代器概念**：迭代器概念用于定义迭代器的基本概念。
- **迭代器基元**：迭代器基元用于定义迭代器的基本操作。
- **迭代器自定义点**：迭代器自定义点用于自定义迭代器的行为。
- **算法概念和实用程序**：算法概念和实用程序用于定义算法的概念和实用程序。
- **流迭代器**：流迭代器用于处理流数据。
- **迭代器适配器**：迭代器适配器用于适配迭代器。
- **迭代器操作**：迭代器操作用于操作迭代器。
- **范围访问**：范围访问用于访问范围。

**范围库**

- **范围访问**：范围访问用于访问范围。
- **范围基元**：范围基元用于定义范围的基本操作。
- **范围转换**：范围转换用于转换范围。
- **悬空迭代器处理**：悬空迭代器处理用于处理悬空迭代器。
- **范围概念**：范围概念用于定义范围的概念。
- **视图**：视图用于提供范围的视图。
- **范围工厂**：范围工厂用于创建范围。
- **范围适配器**：范围适配器用于适配范围。
- **范围生成器**：范围生成器用于生成范围。
- **范围适配器对象**：范围适配器对象用于适配范围。
- **范围适配器闭合对象**：范围适配器闭合对象用于适配范围。
- **辅助项目**：辅助项目用于提供辅助功能。

**算法库**

- **约束算法和范围算法**：约束算法和范围算法用于处理约束和范围。
- **执行策略**：执行策略用于指定算法的执行策略。
- **非修改序列操作**：非修改序列操作用于操作序列而不修改序列。
- **修改序列操作**：修改序列操作用于修改序列。
- **排序和相关操作**：排序和相关操作用于排序和相关操作。
- **数值操作**：数值操作用于进行数值操作。
- **未初始化内存操作**：未初始化内存操作用于操作未初始化的内存。
- **C 库**：C 库包括 C 语言的算法函数。

**字符串库**

- **字符**：字符用于表示字符。
- **库组件**：库组件用于提供字符串库的组件。
- **字符串类**：字符串类用于表示字符串。
- **字符串视图类**：字符串视图类用于提供字符串的视图。
- **相关库**：相关库用于提供相关的库功能。

**文本处理库**

- **本地化库**：本地化库用于支持本地化。
- **正则表达式库**：正则表达式库用于处理正则表达式。
- **格式化库**：格式化库用于格式化文本。
- **以空字符结尾的序列工具**：以空字符结尾的序列工具用于处理以空字符结尾的序列。
- **基本数值转换**：基本数值转换用于进行基本数值转换。
- **文本编码标识**：文本编码标识用于标识文本编码。

**数字库**

- **常用数学函数**：常用数学函数用于进行数学计算。
- **数学特殊函数**：数学特殊函数用于进行特殊的数学计算。
- **数学常数**：数学常数用于提供数学常数。
- **基本线性代数算法**：基本线性代数算法用于进行线性代数计算。
- **数据并行类型**：数据并行类型用于支持数据并行。
- **浮点环境**：浮点环境用于控制浮点运算环境。
- **数值数组**：数值数组用于存储数值。
- **复数运算**：复数运算用于进行复数运算。
- **伪随机数生成**：伪随机数生成用于生成伪随机数。
- **位操作**：位操作用于操作位。
- **通用数字运算**：通用数字运算用于进行通用数字运算。
- **因数运算**：因数运算用于进行因数运算。
- **插值运算**：插值运算用于进行插值运算。
- **饱和算术**：饱和算术用于进行饱和算术。
- **检查整数算术**：检查整数算术用于检查整数算术。

**日期和时间库**

- **chrono库**：chrono库用于处理日期和时间。
- **C风格日期时间库**：C风格日期时间库用于处理C风格的日期和时间。
- **时间点**：时间点用于表示时间点。
- **持续时间**：持续时间用于表示持续时间。
- **时钟**：时钟用于获取时间。
- **一天中的时间**：一天中的时间用于表示一天中的时间。
- **日历**：日历用于表示日历。
- **Chrono I/O**：Chrono I/O用于处理Chrono的输入输出。
- **时区**：时区用于处理时区。
- **字面量**：字面量用于表示字面量。

**输入/输出库**

- **I/O操作器**：I/O操作器用于处理输入输出。
- **打印函数**：打印函数用于打印数据。
- **C风格I/O**：C风格I/O用于处理C风格的输入输出。
- **缓冲区**：缓冲区用于缓冲数据。
- **基于流的I/O**：基于流的I/O用于处理基于流的输入输出。
- **抽象类**：抽象类用于定义抽象类。
- **文件I/O**：文件I/O用于处理文件输入输出。
- **字符串I/O**：字符串I/O用于处理字符串输入输出。
- **数组I/O**：数组I/O用于处理数组输入输出。
- **同步输出**：同步输出用于同步输出。
- **常用类型定义**：常用类型定义用于定义常用类型。
- **预定义标准流对象**：预定义标准流对象用于提供预定义的标准流对象。
- **错误分类接口**：错误分类接口用于分类错误。

**并发支持库**

- **线程管理**：线程管理用于管理线程。
- **协作取消**：协作取消用于取消线程。
- **缓存大小访问**：缓存大小访问用于访问缓存大小。
- **互斥锁**：互斥锁用于保护共享资源。
- **条件变量**：条件变量用于同步线程。
- **信号量**：信号量用于控制资源访问。
- **门闩和屏障**：门闩和屏障用于同步线程。
- **期程**：期程用于处理异步操作。
- **安全回收**：安全回收用于安全回收资源。
- **危险指示**：危险指示用于指示危险操作。
- **原子类型**：原子类型用于原子操作。
- **内存排序**：内存排序用于控制内存访问顺序。
- **原子操作的自由函数**：原子操作的自由函数用于进行原子操作。
- **原子标志的自由函数**：原子标志的自由函数用于进行原子标志操作。

**执行控制库**

- **执行概念**：执行概念用于定义执行的基本概念。
- **实用组件**：实用组件用于提供实用组件。
- **核心操作**：核心操作用于进行核心操作。
- **发送者算法**：发送者算法用于处理发送者。

**C 兼容标头**

- **C风格头文件**：C风格头文件用于提供C风格的头文件。
- **C++风格头文件**：C++风格头文件用于提供C++风格的头文件。

---

### 命名要求

| 命名要求     | 内容                                                         |
| ------------ | ------------------------------------------------------------ |
| C++ 命名要求 | 基本要求，类型属性，库级要求，容器要求，迭代器要求，流I/O要求，格式化要求（C++20），随机数生成要求，并发要求，范围要求（C++20），多维视图定制（C++23），其他要求 |

#### 知识增强：命名要求详解

**基本要求**：基本要求是指命名的基本规则，如标识符必须以字母或下划线开头，后面可以跟字母、数字或下划线。

**类型属性**：类型属性是指类型的特性，如是否为整型、浮点型、指针类型等。

**库级要求**：库级要求是指库的特性，如是否支持多线程、是否支持异常等。

**容器要求**：容器要求是指容器的特性，如是否支持随机访问、是否支持插入和删除等。

**迭代器要求**：迭代器要求是指迭代器的特性，如是否支持前向迭代、是否支持双向迭代等。

**流I/O要求**：流I/O要求是指流I/O的特性，如是否支持格式化输入输出、是否支持缓冲等。

**格式化要求（C++20）**：格式化要求是指格式化的特性，如是否支持格式化字符串、是否支持格式化参数等。

**随机数生成要求**：随机数生成要求是指随机数生成的特性，如是否支持伪随机数生成、是否支持真随机数生成等。

**并发要求**：并发要求是指并发的特性，如是否支持多线程、是否支持同步等。

**范围要求（C++20）**：范围要求是指范围的特性，如是否支持范围访问、是否支持范围转换等。

**多维视图定制（C++23）**：多维视图定制是指多维视图的特性，如是否支持多维视图、是否支持多维视图定制等。

**其他要求**：其他要求是指其他未列出的特性。

---

### 功能测试

| 功能特性测试       | 内容                                                   |
| ------------------ | ------------------------------------------------------ |
| C++ 功能特性测试宏 | 属性特性测试，语言特性测试，库特性测试，编译器功能转储 |

#### 知识增强：功能测试详解

**属性特性测试**：属性特性测试用于检测编译器是否支持某些属性，如 `[[noreturn]]`、`[[deprecated]]` 等。

**语言特性测试**：语言特性测试用于检测编译器是否支持某些语言特性，如 `auto`、`constexpr`、`noexcept` 等。

**库特性测试**：库特性测试用于检测编译器是否支持某些库特性，如 `std::optional`、`std::variant`、`std::any` 等。

**编译器功能转储**：编译器功能转储用于获取编译器支持的所有功能列表。

---

### 技术规格

| 技术规格                           | 内容                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| 实验性-功能标准库扩展（库基础 TS） | 标准库扩展，并行度库扩展，并发库扩展，事务内存（TM TS），概念（概念 TS），范围（范围 TS），协程（协程 TS），网络（网络 TS），模块（模块 TS），反射（反射 TS），TR/TS 规格，非 TS 提案 |

#### 知识增强：技术规格详解

**标准库扩展**：标准库扩展是指对标准库的扩展，如增加新的容器、算法等。

**并行度库扩展**：并行度库扩展是指对并行度库的扩展，如增加新的并行算法等。

**并发库扩展**：并发库扩展是指对并发库的扩展，如增加新的并发工具等。

**事务内存（TM TS）**：事务内存是指支持事务性操作的内存管理技术。

**概念（概念 TS）**：概念是指用于限制模板参数的类型。

**范围（范围 TS）**：范围是指用于处理范围数据的技术。

**协程（协程 TS）**：协程是指用于实现异步编程的技术。

**网络（网络 TS）**：网络是指用于处理网络通信的技术。

**模块（模块 TS）**：模块是指用于替代传统头文件机制的技术。

**反射（反射 TS）**：反射是指用于在运行时获取类型信息的技术。

**TR/TS 规格**：TR/TS 规格是指技术报告和技术规范，用于描述实验性的或尚未正式纳入标准的功能。

**非 TS 提案**：非 TS 提案是指尚未被正式纳入标准但正在讨论中的提案。

---

### 有用资源

| 有用资源               | 内容                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 标准C++基金会          | C++ FAQ，isocpp.org                                          |
| C++常见问题解答        | Bjarne Stroustrup FAQ，Bjarne Stroustrup C++11 FAQ，StackOverflow.com C++ FAQ |
| C++标准文档和草案      | JTC1/SC22/WG21，cplusplus/draft，eel.is/c++draft             |
| C++语言和库参考        | 商业实现参考，开源实现参考，社区资源                         |
| C++ ABI                | Itanium C++ ABI，System V ABI，ARM C++ ABI                   |
| 模式，习语，提示和技巧 | C++ Core Guidelines，C++ Patterns，More C++ Idioms，CeePlusPlusIdioms，Welcome Back to C++ |
| 相关标准               | JTC1/SC22/WG14，POSIX.1-2024/IEEE Std 1003.1-2024，The Unicode Standard |
| 非 ANSI/ISO C++ 库列表 | 包管理器，开源库                                             |

#### 知识增强：有用资源详解

**标准C++基金会**：标准C++基金会是一个非营利组织，致力于推广和维护C++标准。它提供了C++ FAQ和isocpp.org网站，是学习C++的重要资源。

**C++常见问题解答**：C++常见问题解答包括Bjarne Stroustrup FAQ、Bjarne Stroustrup C++11 FAQ和StackOverflow.com C++ FAQ，涵盖了C++的常见问题和解决方案。

**C++标准文档和草案**：C++标准文档和草案包括JTC1/SC22/WG21、cplusplus/draft和eel.is/c++draft，提供了C++标准的官方文档和最新草案。

**C++语言和库参考**：C++语言和库参考包括商业实现参考、开源实现参考和社区资源，提供了C++语言和库的详细参考。

**C++ ABI**：C++ ABI包括Itanium C++ ABI、System V ABI和ARM C++ ABI，定义了C++程序如何与操作系统交互。

**模式，习语，提示和技巧**：模式，习语，提示和技巧包括C++ Core Guidelines、C++ Patterns、More C++ Idioms、CeePlusPlusIdioms和Welcome Back to C++，提供了C++编程的最佳实践和技巧。

**相关标准**：相关标准包括JTC1/SC22/WG14、POSIX.1-2024/IEEE Std 1003.1-2024和The Unicode Standard，提供了与C++相关的其他标准。

**非 ANSI/ISO C++ 库列表**：非 ANSI/ISO C++ 库列表包括包管理器和开源库，提供了C++的第三方库资源。

---

来源：[cppreference.com](https://en.cppreference.com/index.html)
