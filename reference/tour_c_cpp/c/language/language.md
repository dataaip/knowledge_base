# C 语言概念（知识增强版）

---

## 基础概念

| 基础概念           | 内容                                                         |
| ------------------ | ------------------------------------------------------------ |
| 注释               | 单行(`//`)、多行(`/* */`)，预处理前被空格替换                |
| ASCII编码          | 7位字符编码标准(0-127)，基础字符集实现                       |
| 字符集             | 基本源字符集(字母/数字/标点) + 执行字符集                    |
| 翻译阶段           | 1. 字符映射 2. 行拼接 3. 预处理 4. 转义序列处理 5. 拼接字符串 6. 语法分析 7. 链接 |
| 标点符号           | 运算符外的语法符号(`[]`, `{}`, `;`, `,`等)                   |
| 标识符             | 字母/数字/下划线组成，区分大小写，非数字开头                 |
| 作用域             | 块作用域、文件作用域、函数作用域、函数原型作用域             |
| 生命周期           | 自动存储期(栈)、静态存储期(全局)、线程存储期(`_Thread_local`)、动态分配(堆) |
| 名称查找与命名空间 | 标签命名空间、结构体/联合体/枚举空间、普通标识符空间         |
| 类型               | 基础类型 + 派生类型(指针/数组/函数/结构体/联合体)            |
| 算术类型           | 整型(`char`, `int`等) + 浮点型(`float`, `double`)            |
| 对象与对齐         | 内存区域存储数据，`alignof`获取对齐要求，`_Alignas`指定对齐  |
| 主函数 `main`      | 程序入口，`int main(int argc, char* argv[])`，返回值0成功    |
| 如同规则           | 编译器可优化代码，只要可观测行为符合标准                     |
| 未定义行为UB       | 标准未定义行为(如空指针解引用)，结果不可预测                 |
| 内存模型与数据竞争 | C11引入，多线程访问共享数据需同步(`mutex`/原子操作)          |

### 知识增强

#### 注释

C语言支持两种注释方式：

- 单行注释：`//`，从`//`开始到行尾的所有内容都会被忽略。
- 多行注释：`/* */`，可以跨越多行，但不能嵌套。

在预处理阶段，注释会被替换为空格，因此不会影响程序的语法结构。

#### ASCII编码

ASCII（American Standard Code for Information Interchange）是一种基于拉丁字母的字符编码标准，使用7位二进制数表示128个字符（0-127）。其中包括控制字符（如换行符、回车符）、数字、大小写字母和标点符号。

#### 字符集

C语言中的字符集分为两类：

- **基本源字符集**：包括字母（A-Z, a-z）、数字（0-9）、标点符号（如`_`, `{`, `}`, `[`, `]`, `#`, `(`, `)`, `<`, `>`, `%`, `:`, `;`, `.`）等。
- **执行字符集**：用于程序执行时的字符表示，通常与目标平台相关。

#### 翻译阶段

C语言源代码的翻译过程分为多个阶段：

1. **字符映射**：将源文件中的字符映射到基本源字符集。
2. **行拼接**：处理反斜杠续行符（`\`）。
3. **预处理**：处理宏定义、条件编译等预处理指令。
4. **转义序列处理**：处理字符串和字符常量中的转义序列（如`\n`, `\t`）。
5. **拼接字符串**：将相邻的字符串字面量拼接在一起。
6. **语法分析**：进行词法和语法分析，生成抽象语法树。
7. **链接**：将多个目标文件链接成可执行文件。

#### 标点符号

标点符号是C语言中除运算符外的语法符号，用于分隔语句、表达式等。常见的标点符号包括：

- 方括号 `[]`：用于数组索引。
- 花括号 `{}`：用于复合语句或初始化列表。
- 分号 `;`：用于结束语句。
- 逗号 `,`：用于分隔参数或表达式。

#### 标识符

标识符是程序员定义的名称，用于命名变量、函数、类型等。标识符的命名规则如下：

- 只能由字母（A-Z, a-z）、数字（0-9）和下划线（_）组成。
- 不能以数字开头。
- 区分大小写，例如`variable`和`Variable`是不同的标识符。

#### 作用域

作用域决定了标识符在程序中的可见性范围：

- **块作用域**：在复合语句（如`{}`）内部定义的标识符，仅在该块内可见。
- **文件作用域**：在文件顶层定义的标识符，在整个文件中可见。
- **函数作用域**：仅适用于标签（label），在整个函数内可见。
- **函数原型作用域**：在函数原型声明中定义的标识符，仅在该原型中可见。

#### 生命周期

生命周期决定了对象在程序运行期间的存在时间：

- **自动存储期**：局部变量默认具有自动存储期，存储在栈上，函数调用结束后自动销毁。
- **静态存储期**：全局变量和静态变量具有静态存储期，存储在全局数据区，程序启动时创建，程序结束时销毁。
- **线程存储期**：使用`_Thread_local`关键字声明的变量，每个线程都有独立的副本。
- **动态分配**：通过`malloc`、`calloc`等函数动态分配的内存，存储在堆上，需要手动释放。

#### 名称查找与命名空间

C语言中有多个命名空间，用于避免名称冲突：

- **标签命名空间**：用于`goto`语句的目标标签。
- **结构体/联合体/枚举空间**：用于结构体、联合体和枚举类型的标签。
- **普通标识符空间**：用于变量、函数、类型别名等。

#### 类型

C语言的类型系统包括基础类型和派生类型：

- **基础类型**：如`int`、`char`、`float`、`double`等。
- **派生类型**：如指针、数组、函数、结构体、联合体等。

#### 算术类型

算术类型包括整型和浮点型：

- **整型**：如`char`、`short`、`int`、`long`、`long long`等。
- **浮点型**：如`float`、`double`、`long double`等。

#### 对象与对齐

对象是内存中存储数据的区域。C11引入了对齐支持：

- `alignof`：获取类型的对齐要求。
- `_Alignas`：指定对象的对齐方式。

#### 主函数 `main`

`main`函数是程序的入口点，其标准形式为：

```c
int main(int argc, char* argv[])
```

- `argc`：命令行参数的数量。
- `argv`：指向命令行参数的指针数组。
- 返回值为0表示程序正常退出。

#### 如同规则

如同规则（as-if rule）允许编译器对代码进行优化，只要优化后的代码与原始代码在可观测行为上一致。

#### 未定义行为UB

未定义行为是指标准未规定其行为的结果，可能导致程序崩溃、产生错误结果或表现出不可预测的行为。例如：

- 空指针解引用。
- 数组越界访问。
- 除以零。

#### 内存模型与数据竞争

C11引入了内存模型，用于支持多线程编程。当多个线程同时访问共享数据且至少有一个线程进行写操作时，必须使用同步机制（如互斥锁、原子操作）来避免数据竞争。

---

## 关键字

| 关键字                | 内容                                                         |
| --------------------- | ------------------------------------------------------------ |
| 标准关键字            | `auto`, `break`, `case`, `char`, `const`, `continue` 等32个  |
| C99新增关键字         | `_Bool`, `_Complex`, `_Imaginary`, `inline`, `restrict`      |
| C11新增关键字         | `_Alignas`, `_Alignof`, `_Atomic`, `_Generic`, `_Noreturn`, `_Static_assert`, `_Thread_local` |
| C23新增关键字         | `alignas`, `alignof`, `bool`, `constexpr`, `false`, `true`, `nullptr` |
| 条件支持 asm, fortran | 编译器扩展关键字，用于内联汇编(`__asm__`)或Fortran互操作     |

### 知识增强

#### 标准关键字

C语言的标准关键字共有32个，涵盖了基本的控制结构、数据类型、存储类说明符等。这些关键字是C语言的核心组成部分，不能用作标识符。

#### C99新增关键字

C99标准引入了以下关键字：

- `_Bool`：布尔类型。
- `_Complex`：复数类型。
- `_Imaginary`：虚数类型。
- `inline`：建议编译器内联展开函数。
- `restrict`：指针限定符，表示指针是访问对象的唯一方式。

#### C11新增关键字

C11标准引入了以下关键字：

- `_Alignas`：指定对象的对齐方式。
- `_Alignof`：获取类型的对齐要求。
- `_Atomic`：原子类型限定符。
- `_Generic`：泛型选择。
- `_Noreturn`：函数不返回。
- `_Static_assert`：编译时断言。
- `_Thread_local`：线程局部存储。

#### C23新增关键字

C23标准引入了以下关键字：

- `alignas`：`_Alignas`的别名。
- `alignof`：`_Alignof`的别名。
- `bool`：`_Bool`的别名。
- `constexpr`：编译时常量。
- `false`：布尔假值。
- `true`：布尔真值。
- `nullptr`：空指针常量。

#### 条件支持 asm, fortran

某些编译器支持扩展关键字，如`__asm__`用于内联汇编，`__fortran`用于与Fortran语言互操作。

---

## 预处理器

| 预处理器                          | 内容                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| 条件编译指令，C23新增条件判断指令 | `#if`, `#ifdef`, `#elif`, `#else`, `#endif` + C23 `#elifdef`/`#elifndef` |
| 宏定义指令，字符串化/粘贴操作     | `#define`, `#undef` + `#`(字符串化), `##`(标记粘贴)          |
| 文件包含指令                      | `#include <>`(系统头文件) / `#include ""`(用户头文件)        |
| 编译器特定指令                    | `#pragma` 编译器扩展(如优化控制)                             |
| 行号与文件名                      | `#line <num> "filename"` 修改行号/文件名                     |
| 错误控制指令，C23新增警告提示指令 | `#error "msg"` 强制错误 + C23 `#warning "msg"`               |
| 其他控制指令，C23新增资源嵌入支持 | `#`(空指令) + C23 `#embed` 二进制资源嵌入                    |

### 知识增强

#### 条件编译指令

条件编译指令用于根据条件选择性地编译代码：

- `#if`：如果条件为真，则编译后续代码。
- `#ifdef`：如果宏已定义，则编译后续代码。
- `#elif`：否则如果条件为真，则编译后续代码。
- `#else`：否则编译后续代码。
- `#endif`：结束条件编译块。

C23新增了`#elifdef`和`#elifndef`，分别用于检查宏是否定义或未定义。

#### 宏定义指令

宏定义指令用于定义宏：

- `#define`：定义宏。
- `#undef`：取消宏定义。

宏还可以进行字符串化和标记粘贴操作：

- `#`：将宏参数转换为字符串。
- `##`：将两个标记粘贴在一起。

#### 文件包含指令

文件包含指令用于包含其他文件的内容：

- `#include <>`：包含系统头文件。
- `#include ""`：包含用户头文件。

#### 编译器特定指令

`#pragma`用于向编译器传递特定指令，如优化控制、警告抑制等。

#### 行号与文件名

`#line`指令用于修改当前的行号和文件名，常用于调试信息。

#### 错误控制指令

- `#error`：强制编译器报错并显示指定消息。
- C23新增`#warning`：显示警告消息但不中断编译。

#### 其他控制指令

- `#`：空指令，用于占位。
- C23新增`#embed`：用于嵌入二进制资源。

---

## 语句

| 语句                     | 内容                                |
| ------------------------ | ----------------------------------- |
| 标签语句，返回函数值语句 | `label:` (goto目标), `return expr;` |
| 表达式语句               | 表达式后跟`;` (如`x = 5;`)          |
| 复合语句                 | `{...}` 代码块，创建作用域          |
| 选择语句                 | `if/else`, `switch/case/default`    |
| 迭代语句                 | `for`, `while`, `do-while`          |
| 跳转语句                 | `goto`, `break`, `continue`         |

### 知识增强

#### 标签语句

标签语句用于标记代码位置，通常与`goto`语句配合使用：

```c
label:
    // 代码
```

`return`语句用于从函数返回值：

```c
return expr;
```

#### 表达式语句

表达式语句是由表达式后跟分号组成的语句：

```c
x = 5;
```

#### 复合语句

复合语句是由一对花括号包围的语句块，用于创建新的作用域：

```c
{
    int x = 10;
    // x 在此作用域内可见
}
```

#### 选择语句

选择语句用于根据条件执行不同的代码路径：

- `if/else`：根据条件执行代码。
- `switch/case/default`：根据表达式的值执行不同的代码块。

#### 迭代语句

迭代语句用于重复执行代码：

- `for`：循环执行代码，通常用于已知循环次数的情况。
- `while`：当条件为真时循环执行代码。
- `do-while`：至少执行一次循环体，然后根据条件决定是否继续。

#### 跳转语句

跳转语句用于改变程序的执行流程：

- `goto`：跳转到指定标签。
- `break`：跳出循环或`switch`语句。
- `continue`：跳过当前循环的剩余部分，进入下一次循环。

---

## 表达式

| 表达式           | 内容                                                         |
| ---------------- | ------------------------------------------------------------ |
| 值类别           | 左值(有地址)，右值(临时值)                                   |
| 求值顺序与序列点 | 序列点间求值顺序未定义(如`f() + g()`)                        |
| 常量表达式       | 编译时可求值表达式(如`3+4`)，用于数组大小/枚举值等           |
| 常量与字面量     | 整型(`42`)，浮点(`3.14`)，字符(`'A'`)，布尔(`true/false`)，空指针(`NULL`)，字符串(`"str"`)，复合字面量(`(int[]){1,2}`) |
| 运算符分类       | 成员访问与间接寻址(`.`/`->`)，逻辑(`&&`/`\|\|`)，比较(`==`/`>`)，算术(`+`/`-`)，赋值(`=`/`+=`)，自增/自减(`++`/`--`)，函数调用(`()`)，逗号(`,`)，三元(`?:`)，`sizeof`/`alignof`，类型转换(`(type)`)，运算符优先级，泛型选择 `_Generic` |

### 知识增强

#### 值类别

C语言中的表达式可以分为左值和右值：

- **左值**：具有地址的表达式，可以出现在赋值操作的左侧。
- **右值**：临时值，不能出现在赋值操作的左侧。

#### 求值顺序与序列点

在两个序列点之间，表达式的求值顺序是未定义的。常见的序列点包括：

- 逻辑运算符 `&&` 和 `||`。
- 条件运算符 `?:`。
- 逗号运算符 `,`。
- 函数调用。

#### 常量表达式

常量表达式是在编译时可以求值的表达式，常用于数组大小、枚举值等：

```c
int arr[3 + 4];  // 数组大小为7
```

#### 常量与字面量

C语言支持多种类型的常量和字面量：

- **整型字面量**：如`42`。
- **浮点字面量**：如`3.14`。
- **字符字面量**：如`'A'`。
- **布尔字面量**：如`true`和`false`。
- **空指针字面量**：如`NULL`。
- **字符串字面量**：如`"str"`。
- **复合字面量**：如`(int[]){1, 2}`。

#### 运算符分类

C语言的运算符按功能分类如下：

- **成员访问与间接寻址**：`.`和`->`用于访问结构体或联合体的成员。
- **逻辑运算符**：`&&`和`||`用于逻辑与和逻辑或。
- **比较运算符**：`==`、`!=`、`>`、`<`、`>=`、`<=`用于比较两个值。
- **算术运算符**：`+`、`-`、`*`、`/`、`%`用于算术运算。
- **赋值运算符**：`=`, `+=`, `-=`, `*=`, `/=`, `%=`等用于赋值。
- **自增/自减运算符**：`++`和`--`用于递增或递减。
- **函数调用运算符**：`()`用于调用函数。
- **逗号运算符**：`,`用于分隔表达式。
- **三元运算符**：`?:`用于条件表达式。
- **`sizeof`和`alignof`**：用于获取对象的大小和对齐要求。
- **类型转换**：`(type)`用于显式类型转换。
- **泛型选择**：`_Generic`用于根据表达式的类型选择不同的代码。

---

## 初始化

| 初始化              | 内容                                                     |
| ------------------- | -------------------------------------------------------- |
| 显示初始化          | `int x = 10;` 或指定初始化器(C99) `struct S s = {.a=1};` |
| 隐式初始化          | 静态存储期对象默认0初始化                                |
| 空初始化            | `int x;` (自动存储期未初始化)                            |
| 标量初始化          | 基础类型初始化 `char c = 'X';`                           |
| 数组初始化          | `int arr[3] = {1,2,3};` 或部分初始化(其余为0)            |
| 结构体/联合体初始化 | `struct Point p = {.x=1, .y=2};` 联合体初始化首个成员    |

### 知识增强

#### 显示初始化

显示初始化是指在声明变量时直接赋值：

```c
int x = 10;
```

C99引入了指定初始化器，可以指定结构体或数组的特定成员进行初始化：

```c
struct S {
    int a;
    int b;
};
struct S s = {.a = 1, .b = 2};
```

#### 隐式初始化

静态存储期的对象（如全局变量、静态变量）如果没有显式初始化，会被默认初始化为0：

```c
static int x;  // x 被初始化为0
```

#### 空初始化

自动存储期的对象如果没有显式初始化，其值是未定义的：

```c
int x;  // x 的值未定义
```

#### 标量初始化

标量类型（如`int`、`char`等）可以直接初始化：

```c
char c = 'X';
```

#### 数组初始化

数组可以使用初始化列表进行初始化：

```c
int arr[3] = {1, 2, 3};
```

如果初始化列表中的元素少于数组大小，剩余元素会被初始化为0：

```c
int arr[5] = {1, 2};  // arr[2], arr[3], arr[4] 被初始化为0
```

#### 结构体/联合体初始化

结构体可以使用指定初始化器进行初始化：

```c
struct Point {
    int x;
    int y;
};
struct Point p = {.x = 1, .y = 2};
```

联合体只能初始化第一个成员：

```c
union U {
    int i;
    float f;
};
union U u = {.i = 42};  // 只能初始化第一个成员
```

---

## 声明

| 声明             | 内容                                                         |
| ---------------- | ------------------------------------------------------------ |
| 类型说明符       | `void`，算术(`char`/`int`等)，原子(`_Atomic int`)，`typedef`别名，`typeof`(GNU扩展)，`struct`/`union`/`enum`，位域(`int b:3;`) |
| 存储类说明符     | `typedef`(类型别名)，`constexpr`(C23编译时常量)，`auto`(自动存储期)，`register`(建议寄存器存储)，`static`(静态存储期)，`extern`(外部链接)，`_Thread_local`(线程局部存储) |
| 类型限定符       | `const`(不可修改)，`volatile`(防止优化)，`restrict`(指针独占访问)，`_Atomic`(原子访问) |
| 对齐说明符       | `_Alignas(n)` 或 C23 `alignas(n)` 指定对齐字节数             |
| 初始值设定项     | 声明时赋值表达式                                             |
| 属性声明列表     | `[[attr]]` C23标准属性(如`[[nodiscard]]`)                    |
| 声明定义与重声明 | 多次声明允许(需类型兼容)，单一定义规则(ODR)                  |
| 声明符           | 指针(`*p`)，数组(`arr[10]`)，函数(`int f()`)，枚举(`enum E`)，结构体(`struct S`)，联合体(`union U`)，位域(`int b:4;`) |

### 知识增强

#### 类型说明符

类型说明符用于指定变量或函数的类型：

- `void`：表示无类型。
- 算术类型：如`char`、`int`、`float`、`double`等。
- 原子类型：如`_Atomic int`。
- `typedef`：用于定义类型别名。
- `typeof`：GNU扩展，用于获取表达式的类型。
- 结构体、联合体、枚举：用于定义复合类型。
- 位域：用于指定成员的位数。

#### 存储类说明符

存储类说明符用于指定变量的存储期和链接：

- `typedef`：定义类型别名。
- `constexpr`：C23引入，用于声明编译时常量。
- `auto`：自动存储期（默认）。
- `register`：建议将变量存储在寄存器中。
- `static`：静态存储期。
- `extern`：外部链接。
- `_Thread_local`：线程局部存储。

#### 类型限定符

类型限定符用于限制变量的访问方式：

- `const`：表示变量不可修改。
- `volatile`：防止编译器优化，确保每次访问都从内存中读取。
- `restrict`：表示指针是访问对象的唯一方式。
- `_Atomic`：表示变量是原子访问的。

#### 对齐说明符

对齐说明符用于指定对象的对齐方式：

- `_Alignas(n)`：指定对象的对齐字节数。
- `alignas(n)`：C23引入，`_Alignas`的别名。

#### 初始值设定项

初始值设定项用于在声明时为变量赋值：

```c
int x = 10;
```

#### 属性声明列表

属性声明列表用于为声明添加属性：

- `[[attr]]`：C23引入，用于指定属性，如`[[nodiscard]]`表示函数返回值不应被忽略。

#### 声明定义与重声明

C语言允许多次声明同一个标识符，但要求类型兼容。单一定义规则（ODR）要求每个标识符只能有一个定义。

#### 声明符

声明符用于指定变量的类型和结构：

- 指针：如`*p`。
- 数组：如`arr[10]`。
- 函数：如`int f()`。
- 枚举：如`enum E`。
- 结构体：如`struct S`。
- 联合体：如`union U`。
- 位域：如`int b:4`。

---

## 函数

| 函数      | 内容                                                         |
| --------- | ------------------------------------------------------------ |
| 函数声明  | `int func(int param);` (原型声明)                            |
| 函数定义  | `int func(int param) { ... }` 含函数体                       |
| 可变参数  | `void func(int n, ...);` 用`va_list/va_start/va_arg/va_end`访问 |
| 内联函数  | `inline void f()` 建议编译器内联展开                         |
| _Noreturn | `_Noreturn void exit();` 函数不返回                          |

### 知识增强

#### 函数声明

函数声明用于告诉编译器函数的名称、返回类型和参数类型：

```c
int func(int param);
```

#### 函数定义

函数定义包含函数体，用于实现函数的功能：

```c
int func(int param) {
    // 函数体
}
```

#### 可变参数

可变参数函数允许函数接受不定数量的参数：

```c
void func(int n, ...);
```

使用`va_list`、`va_start`、`va_arg`、`va_end`宏来访问可变参数：

```c
#include <stdarg.h>

void func(int n, ...) {
    va_list args;
    va_start(args, n);
    for (int i = 0; i < n; i++) {
        int arg = va_arg(args, int);
        printf("%d ", arg);
    }
    va_end(args);
}
```

#### 内联函数

内联函数建议编译器将函数调用替换为函数体，以减少函数调用的开销：

```c
inline void f() {
    // 函数体
}
```

#### _Noreturn

`_Noreturn`关键字用于声明函数不会返回：

```c
_Noreturn void exit();
```

---

## 杂项和习语

| 杂项和习语       | 内容                                                  |
| ---------------- | ----------------------------------------------------- |
| C 语言历史       | K&R C(1978) → ANSI C(1989) → C99 → C11 → C17 → C23    |
| 技术规范，合规性 | 遵循ISO/IEC 9899标准，`__STDC_VERSION__`宏检测版本    |
| 内联汇编         | `__asm__("指令" : 输出 : 输入 : 破坏列表)` 编译器扩展 |
| 信号处理         | `signal()`注册信号处理函数(SIGSEGV/SIGINT等)          |
| 可分析性         | `static_assert`编译时断言，C23属性增强代码分析        |

### 知识增强

#### C 语言历史

C语言的发展历程如下：

- **K&R C**：1978年，由Brian Kernighan和Dennis Ritchie编写的第一版C语言。
- **ANSI C**：1989年，由ANSI标准化的C语言，也称为C89。
- **C99**：1999年，引入了许多新特性，如混合声明和代码、复数类型等。
- **C11**：2011年，引入了多线程支持、泛型选择等。
- **C17**：2017年，主要是对C11的修正。
- **C23**：2023年，引入了更多现代化特性，如`constexpr`、`nullptr`等。

#### 技术规范，合规性

C语言遵循ISO/IEC 9899标准，可以通过`__STDC_VERSION__`宏检测编译器支持的C标准版本：

```c
#if __STDC_VERSION__ >= 202311L
    // C23 特性
#elif __STDC_VERSION__ >= 201112L
    // C11 特性
#endif
```

#### 内联汇编

内联汇编是编译器扩展，允许在C代码中嵌入汇编指令：

```c
__asm__("指令" : 输出 : 输入 : 破坏列表);
```

#### 信号处理

信号处理用于处理程序运行时的异常情况，如段错误、中断等：

```c
#include <signal.h>

void handler(int sig) {
    // 信号处理函数
}

int main() {
    signal(SIGSEGV, handler);
    return 0;
}
```

#### 可分析性

C语言提供了多种工具来增强代码的可分析性：

- `static_assert`：编译时断言，用于检查常量表达式。
- C23引入了属性，如`[[nodiscard]]`，用于增强代码分析。

---